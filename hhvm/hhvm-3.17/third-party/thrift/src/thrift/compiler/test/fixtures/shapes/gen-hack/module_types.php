<?hh
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

namespace test\fixtures;

enum \test\fixtures\Enum: int {
  ENUM = 1;
}
type \test\fixtures\EnumType = \test\fixtures\Enum;

class A implements \IThriftStruct, \IThriftShapishStruct {
  public static array $_TSPEC = array(
    1 => array(
      'var' => 'a',
      'type' => \TType::STRING,
      ),
    );
  public static Map<string, int> $_TFIELDMAP = Map {
    'a' => 1,
  };
  const type TShape = shape(
    'a' => string,
  );
  const int STRUCTURAL_ID = 7939807933046472325;
  public string $a;

  public function __construct(?string $a = null  ) {
    if ($a === null) {
      $this->a = '';
    } else {
      $this->a = $a;
    }
  }

  public function getName(): string {
    return 'A';
  }

  public static function __jsonArrayToShape(
    array<arraykey, mixed> $json_data,
  ): ?self::TShape {
    $shape_data = $json_data;

    if (!array_key_exists('a', $shape_data)) {
      $shape_data['a'] = '';
    }
    if (!is_string($shape_data['a'])) {
      return null;
    }

    return /* HH_IGNORE_ERROR[4110] */ $shape_data;
  }

  public static function __fromShape(self::TShape $shape): this {
    $me = /* HH_IGNORE_ERROR[4060] */ new static();
    $me->a = $shape['a'];
    return $me;
  }

  public function __toShape(): self::TShape {
    return shape(
      'a' => $this->a,
    );
  }
  public function read(\TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == \TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == \TType::STRING) {
            $xfer += $input->readString($this->a);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(\TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('A');
    if ($this->a !== null) {
      $_val0 = $this->a;
      $xfer += $output->writeFieldBegin('a', \TType::STRING, 1);
      $xfer += $output->writeString($_val0);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class B implements \IThriftStruct, \IThriftShapishStruct {
  public static array $_TSPEC = array(
    1 => array(
      'var' => 'just_an_A',
      'type' => \TType::STRUCT,
      'class' => '\test\fixtures\A',
      ),
    2 => array(
      'var' => 'set_of_i32',
      'type' => \TType::SET,
      'etype' => \TType::I32,
      'elem' => array(
        'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
    3 => array(
      'var' => 'list_of_i32',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => array(
        'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
    4 => array(
      'var' => 'list_of_string',
      'type' => \TType::LST,
      'etype' => \TType::STRING,
      'elem' => array(
        'type' => \TType::STRING,
        ),
        'format' => 'collection',
      ),
    5 => array(
      'var' => 'map_of_string_to_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::I32,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
    6 => array(
      'var' => 'map_of_string_to_A',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::STRUCT,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::STRUCT,
        'class' => '\test\fixtures\A',
        ),
        'format' => 'collection',
      ),
    7 => array(
      'var' => 'map_of_string_to_list_of_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::LST,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::LST,
        'etype' => \TType::I32,
        'elem' => array(
          'type' => \TType::I32,
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
    8 => array(
      'var' => 'map_of_string_to_list_of_A',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::LST,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::LST,
        'etype' => \TType::STRUCT,
        'elem' => array(
          'type' => \TType::STRUCT,
          'class' => '\test\fixtures\A',
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
    9 => array(
      'var' => 'map_of_string_to_set_of_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::SET,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::SET,
        'etype' => \TType::I32,
        'elem' => array(
          'type' => \TType::I32,
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
    10 => array(
      'var' => 'map_of_string_to_map_of_string_to_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::MAP,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::I32,
        'key' => array(
          'type' => \TType::STRING,
        ),
        'val' => array(
          'type' => \TType::I32,
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
    11 => array(
      'var' => 'map_of_string_to_map_of_string_to_A',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::MAP,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::STRUCT,
        'key' => array(
          'type' => \TType::STRING,
        ),
        'val' => array(
          'type' => \TType::STRUCT,
          'class' => '\test\fixtures\A',
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
    12 => array(
      'var' => 'list_of_set_of_i32',
      'type' => \TType::LST,
      'etype' => \TType::SET,
      'elem' => array(
        'type' => \TType::SET,
        'etype' => \TType::I32,
        'elem' => array(
          'type' => \TType::I32,
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
    13 => array(
      'var' => 'list_of_map_of_string_to_list_of_A',
      'type' => \TType::LST,
      'etype' => \TType::MAP,
      'elem' => array(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::LST,
        'key' => array(
          'type' => \TType::STRING,
        ),
        'val' => array(
          'type' => \TType::LST,
          'etype' => \TType::STRUCT,
          'elem' => array(
            'type' => \TType::STRUCT,
            'class' => '\test\fixtures\A',
            ),
            'format' => 'collection',
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
    14 => array(
      'var' => 'list_of_map_of_string_to_A',
      'type' => \TType::LST,
      'etype' => \TType::MAP,
      'elem' => array(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::STRUCT,
        'key' => array(
          'type' => \TType::STRING,
        ),
        'val' => array(
          'type' => \TType::STRUCT,
          'class' => '\test\fixtures\A',
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
    15 => array(
      'var' => 'list_of_self',
      'type' => \TType::LST,
      'etype' => \TType::STRUCT,
      'elem' => array(
        'type' => \TType::STRUCT,
        'class' => '\test\fixtures\B',
        ),
        'format' => 'collection',
      ),
    16 => array(
      'var' => 'map_of_string_to_self',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::STRUCT,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::STRUCT,
        'class' => '\test\fixtures\B',
        ),
        'format' => 'collection',
      ),
    17 => array(
      'var' => 'just_an_enum',
      'type' => \TType::I32,
      'enum' => '\test\fixtures\Enum',
      ),
    51 => array(
      'var' => 'optional_just_an_A',
      'type' => \TType::STRUCT,
      'class' => '\test\fixtures\A',
      ),
    52 => array(
      'var' => 'optional_set_of_i32',
      'type' => \TType::SET,
      'etype' => \TType::I32,
      'elem' => array(
        'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
    53 => array(
      'var' => 'optional_list_of_i32',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => array(
        'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
    54 => array(
      'var' => 'optional_list_of_string',
      'type' => \TType::LST,
      'etype' => \TType::STRING,
      'elem' => array(
        'type' => \TType::STRING,
        ),
        'format' => 'collection',
      ),
    55 => array(
      'var' => 'optional_map_of_string_to_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::I32,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
    56 => array(
      'var' => 'optional_map_of_string_to_A',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::STRUCT,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::STRUCT,
        'class' => '\test\fixtures\A',
        ),
        'format' => 'collection',
      ),
    57 => array(
      'var' => 'optional_map_of_string_to_list_of_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::LST,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::LST,
        'etype' => \TType::I32,
        'elem' => array(
          'type' => \TType::I32,
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
    58 => array(
      'var' => 'optional_map_of_string_to_list_of_A',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::LST,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::LST,
        'etype' => \TType::STRUCT,
        'elem' => array(
          'type' => \TType::STRUCT,
          'class' => '\test\fixtures\A',
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
    59 => array(
      'var' => 'optional_map_of_string_to_set_of_i32',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::SET,
      'key' => array(
        'type' => \TType::STRING,
      ),
      'val' => array(
        'type' => \TType::SET,
        'etype' => \TType::I32,
        'elem' => array(
          'type' => \TType::I32,
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
    60 => array(
      'var' => 'optional_enum',
      'type' => \TType::I32,
      'enum' => '\test\fixtures\Enum',
      ),
    );
  public static Map<string, int> $_TFIELDMAP = Map {
    'just_an_A' => 1,
    'set_of_i32' => 2,
    'list_of_i32' => 3,
    'list_of_string' => 4,
    'map_of_string_to_i32' => 5,
    'map_of_string_to_A' => 6,
    'map_of_string_to_list_of_i32' => 7,
    'map_of_string_to_list_of_A' => 8,
    'map_of_string_to_set_of_i32' => 9,
    'map_of_string_to_map_of_string_to_i32' => 10,
    'map_of_string_to_map_of_string_to_A' => 11,
    'list_of_set_of_i32' => 12,
    'list_of_map_of_string_to_list_of_A' => 13,
    'list_of_map_of_string_to_A' => 14,
    'list_of_self' => 15,
    'map_of_string_to_self' => 16,
    'just_an_enum' => 17,
    'optional_just_an_A' => 51,
    'optional_set_of_i32' => 52,
    'optional_list_of_i32' => 53,
    'optional_list_of_string' => 54,
    'optional_map_of_string_to_i32' => 55,
    'optional_map_of_string_to_A' => 56,
    'optional_map_of_string_to_list_of_i32' => 57,
    'optional_map_of_string_to_list_of_A' => 58,
    'optional_map_of_string_to_set_of_i32' => 59,
    'optional_enum' => 60,
  };
  const type TShape = shape(
    'just_an_A' => ?\test\fixtures\A::TShape,
    'set_of_i32' => array<int, bool>,
    'list_of_i32' => array<int>,
    'list_of_string' => array<string>,
    'map_of_string_to_i32' => array<string, int>,
    'map_of_string_to_A' => array<string, \test\fixtures\A::TShape>,
    'map_of_string_to_list_of_i32' => array<string, array<int>>,
    'map_of_string_to_list_of_A' => array<string, array<\test\fixtures\A::TShape>>,
    'map_of_string_to_set_of_i32' => array<string, array<int, bool>>,
    'map_of_string_to_map_of_string_to_i32' => array<string, array<string, int>>,
    'map_of_string_to_map_of_string_to_A' => array<string, array<string, \test\fixtures\A::TShape>>,
    'list_of_set_of_i32' => array<array<int, bool>>,
    'list_of_map_of_string_to_list_of_A' => array<array<string, array<\test\fixtures\A::TShape>>>,
    'list_of_map_of_string_to_A' => array<array<string, \test\fixtures\A::TShape>>,
    'list_of_self' => array<\test\fixtures\B::TShape>,
    'map_of_string_to_self' => array<string, \test\fixtures\B::TShape>,
    'just_an_enum' => ?\test\fixtures\Enum,
    'optional_just_an_A' => ?\test\fixtures\A::TShape,
    'optional_set_of_i32' => ?array<int, bool>,
    'optional_list_of_i32' => ?array<int>,
    'optional_list_of_string' => ?array<string>,
    'optional_map_of_string_to_i32' => ?array<string, int>,
    'optional_map_of_string_to_A' => ?array<string, \test\fixtures\A::TShape>,
    'optional_map_of_string_to_list_of_i32' => ?array<string, array<int>>,
    'optional_map_of_string_to_list_of_A' => ?array<string, array<\test\fixtures\A::TShape>>,
    'optional_map_of_string_to_set_of_i32' => ?array<string, array<int, bool>>,
    'optional_enum' => ?\test\fixtures\Enum,
  );
  const int STRUCTURAL_ID = 8418159757686116954;
  public ?\test\fixtures\A $just_an_A;
  public Set<int> $set_of_i32;
  public Vector<int> $list_of_i32;
  public Vector<string> $list_of_string;
  public Map<string, int> $map_of_string_to_i32;
  public Map<string, \test\fixtures\A> $map_of_string_to_A;
  public Map<string, Vector<int>> $map_of_string_to_list_of_i32;
  public Map<string, Vector<\test\fixtures\A>> $map_of_string_to_list_of_A;
  public Map<string, Set<int>> $map_of_string_to_set_of_i32;
  public Map<string, Map<string, int>> $map_of_string_to_map_of_string_to_i32;
  public Map<string, Map<string, \test\fixtures\A>> $map_of_string_to_map_of_string_to_A;
  public Vector<Set<int>> $list_of_set_of_i32;
  public Vector<Map<string, Vector<\test\fixtures\A>>> $list_of_map_of_string_to_list_of_A;
  public Vector<Map<string, \test\fixtures\A>> $list_of_map_of_string_to_A;
  public Vector<\test\fixtures\B> $list_of_self;
  public Map<string, \test\fixtures\B> $map_of_string_to_self;
  public ?\test\fixtures\Enum $just_an_enum;
  public ?\test\fixtures\A $optional_just_an_A;
  public ?Set<int> $optional_set_of_i32;
  public ?Vector<int> $optional_list_of_i32;
  public ?Vector<string> $optional_list_of_string;
  public ?Map<string, int> $optional_map_of_string_to_i32;
  public ?Map<string, \test\fixtures\A> $optional_map_of_string_to_A;
  public ?Map<string, Vector<int>> $optional_map_of_string_to_list_of_i32;
  public ?Map<string, Vector<\test\fixtures\A>> $optional_map_of_string_to_list_of_A;
  public ?Map<string, Set<int>> $optional_map_of_string_to_set_of_i32;
  public ?\test\fixtures\Enum $optional_enum;

  public function __construct(?\test\fixtures\A $just_an_A = null, ?Set<int> $set_of_i32 = null, ?Vector<int> $list_of_i32 = null, ?Vector<string> $list_of_string = null, ?Map<string, int> $map_of_string_to_i32 = null, ?Map<string, \test\fixtures\A> $map_of_string_to_A = null, ?Map<string, Vector<int>> $map_of_string_to_list_of_i32 = null, ?Map<string, Vector<\test\fixtures\A>> $map_of_string_to_list_of_A = null, ?Map<string, Set<int>> $map_of_string_to_set_of_i32 = null, ?Map<string, Map<string, int>> $map_of_string_to_map_of_string_to_i32 = null, ?Map<string, Map<string, \test\fixtures\A>> $map_of_string_to_map_of_string_to_A = null, ?Vector<Set<int>> $list_of_set_of_i32 = null, ?Vector<Map<string, Vector<\test\fixtures\A>>> $list_of_map_of_string_to_list_of_A = null, ?Vector<Map<string, \test\fixtures\A>> $list_of_map_of_string_to_A = null, ?Vector<\test\fixtures\B> $list_of_self = null, ?Map<string, \test\fixtures\B> $map_of_string_to_self = null, ?\test\fixtures\Enum $just_an_enum = null, ?\test\fixtures\A $optional_just_an_A = null, ?Set<int> $optional_set_of_i32 = null, ?Vector<int> $optional_list_of_i32 = null, ?Vector<string> $optional_list_of_string = null, ?Map<string, int> $optional_map_of_string_to_i32 = null, ?Map<string, \test\fixtures\A> $optional_map_of_string_to_A = null, ?Map<string, Vector<int>> $optional_map_of_string_to_list_of_i32 = null, ?Map<string, Vector<\test\fixtures\A>> $optional_map_of_string_to_list_of_A = null, ?Map<string, Set<int>> $optional_map_of_string_to_set_of_i32 = null, ?\test\fixtures\Enum $optional_enum = null  ) {
    $this->just_an_A = $just_an_A;
    if ($set_of_i32 === null) {
      $this->set_of_i32 = Set {};
    } else {
      $this->set_of_i32 = $set_of_i32;
    }
    if ($list_of_i32 === null) {
      $this->list_of_i32 = Vector {};
    } else {
      $this->list_of_i32 = $list_of_i32;
    }
    if ($list_of_string === null) {
      $this->list_of_string = Vector {};
    } else {
      $this->list_of_string = $list_of_string;
    }
    if ($map_of_string_to_i32 === null) {
      $this->map_of_string_to_i32 = Map {};
    } else {
      $this->map_of_string_to_i32 = $map_of_string_to_i32;
    }
    if ($map_of_string_to_A === null) {
      $this->map_of_string_to_A = Map {};
    } else {
      $this->map_of_string_to_A = $map_of_string_to_A;
    }
    if ($map_of_string_to_list_of_i32 === null) {
      $this->map_of_string_to_list_of_i32 = Map {};
    } else {
      $this->map_of_string_to_list_of_i32 = $map_of_string_to_list_of_i32;
    }
    if ($map_of_string_to_list_of_A === null) {
      $this->map_of_string_to_list_of_A = Map {};
    } else {
      $this->map_of_string_to_list_of_A = $map_of_string_to_list_of_A;
    }
    if ($map_of_string_to_set_of_i32 === null) {
      $this->map_of_string_to_set_of_i32 = Map {};
    } else {
      $this->map_of_string_to_set_of_i32 = $map_of_string_to_set_of_i32;
    }
    if ($map_of_string_to_map_of_string_to_i32 === null) {
      $this->map_of_string_to_map_of_string_to_i32 = Map {};
    } else {
      $this->map_of_string_to_map_of_string_to_i32 = $map_of_string_to_map_of_string_to_i32;
    }
    if ($map_of_string_to_map_of_string_to_A === null) {
      $this->map_of_string_to_map_of_string_to_A = Map {};
    } else {
      $this->map_of_string_to_map_of_string_to_A = $map_of_string_to_map_of_string_to_A;
    }
    if ($list_of_set_of_i32 === null) {
      $this->list_of_set_of_i32 = Vector {};
    } else {
      $this->list_of_set_of_i32 = $list_of_set_of_i32;
    }
    if ($list_of_map_of_string_to_list_of_A === null) {
      $this->list_of_map_of_string_to_list_of_A = Vector {};
    } else {
      $this->list_of_map_of_string_to_list_of_A = $list_of_map_of_string_to_list_of_A;
    }
    if ($list_of_map_of_string_to_A === null) {
      $this->list_of_map_of_string_to_A = Vector {};
    } else {
      $this->list_of_map_of_string_to_A = $list_of_map_of_string_to_A;
    }
    if ($list_of_self === null) {
      $this->list_of_self = Vector {};
    } else {
      $this->list_of_self = $list_of_self;
    }
    if ($map_of_string_to_self === null) {
      $this->map_of_string_to_self = Map {};
    } else {
      $this->map_of_string_to_self = $map_of_string_to_self;
    }
    $this->just_an_enum = $just_an_enum;
    $this->optional_just_an_A = $optional_just_an_A;
    $this->optional_set_of_i32 = $optional_set_of_i32;
    $this->optional_list_of_i32 = $optional_list_of_i32;
    $this->optional_list_of_string = $optional_list_of_string;
    $this->optional_map_of_string_to_i32 = $optional_map_of_string_to_i32;
    $this->optional_map_of_string_to_A = $optional_map_of_string_to_A;
    $this->optional_map_of_string_to_list_of_i32 = $optional_map_of_string_to_list_of_i32;
    $this->optional_map_of_string_to_list_of_A = $optional_map_of_string_to_list_of_A;
    $this->optional_map_of_string_to_set_of_i32 = $optional_map_of_string_to_set_of_i32;
    $this->optional_enum = $optional_enum;
  }

  public function getName(): string {
    return 'B';
  }

  public static function __jsonArrayToShape(
    array<arraykey, mixed> $json_data,
  ): ?self::TShape {
    $shape_data = $json_data;

    if (!array_key_exists('just_an_A', $shape_data)) {
      $shape_data['just_an_A'] = null;
    }
    if (!is_null($shape_data['just_an_A'])) {
      $shape_data['just_an_A'] = \test\fixtures\A::__jsonArrayToShape(/* HH_IGNORE_ERROR[4110] */ $shape_data['just_an_A']);
      if (is_null($shape_data['just_an_A'])) {
        return null;
      }
    }

    if (!array_key_exists('set_of_i32', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['set_of_i32'])) {
      return null;
    }
    $the_set2 = array();
    foreach (/* HH_IGNORE_ERROR[4110] */ $shape_data['set_of_i32'] as $key0 => $shape_data1) {
      if (!is_int($shape_data1)) {
        return null;
      }
      $the_set2[$shape_data1] = true;
    }
    $shape_data['set_of_i32'] = $the_set2;

    if (!array_key_exists('list_of_i32', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['list_of_i32'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['list_of_i32'] as $key3 => $value4) {
      if (!is_int($key3)) {
        return null;
      }
      if (!is_int($value4)) {
        return null;
      }
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['list_of_i32'][$key3] = $value4;
    }

    if (!array_key_exists('list_of_string', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['list_of_string'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['list_of_string'] as $key5 => $value6) {
      if (!is_int($key5)) {
        return null;
      }
      if (!is_string($value6)) {
        return null;
      }
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['list_of_string'][$key5] = $value6;
    }

    if (!array_key_exists('map_of_string_to_i32', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['map_of_string_to_i32'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['map_of_string_to_i32'] as $key7 => $value8) {
      if (!is_string($key7)) {
        return null;
      }
      if (!is_int($value8)) {
        return null;
      }
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['map_of_string_to_i32'][$key7] = $value8;
    }

    if (!array_key_exists('map_of_string_to_A', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['map_of_string_to_A'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['map_of_string_to_A'] as $key9 => $value10) {
      if (!is_string($key9)) {
        return null;
      }
      $value10 = \test\fixtures\A::__jsonArrayToShape(/* HH_IGNORE_ERROR[4110] */ $value10);
      if (is_null($value10)) {
        return null;
      }
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['map_of_string_to_A'][$key9] = $value10;
    }

    if (!array_key_exists('map_of_string_to_list_of_i32', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['map_of_string_to_list_of_i32'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['map_of_string_to_list_of_i32'] as $key11 => $value12) {
      if (!is_string($key11)) {
        return null;
      }
      if (!is_array($value12)) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$value12 as $key13 => $value14) {
        if (!is_int($key13)) {
          return null;
        }
        if (!is_int($value14)) {
          return null;
        }
        /* HH_IGNORE_ERROR[4005] */
        $value12[$key13] = $value14;
      }
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['map_of_string_to_list_of_i32'][$key11] = $value12;
    }

    if (!array_key_exists('map_of_string_to_list_of_A', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['map_of_string_to_list_of_A'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['map_of_string_to_list_of_A'] as $key15 => $value16) {
      if (!is_string($key15)) {
        return null;
      }
      if (!is_array($value16)) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$value16 as $key17 => $value18) {
        if (!is_int($key17)) {
          return null;
        }
        $value18 = \test\fixtures\A::__jsonArrayToShape(/* HH_IGNORE_ERROR[4110] */ $value18);
        if (is_null($value18)) {
          return null;
        }
        /* HH_IGNORE_ERROR[4005] */
        $value16[$key17] = $value18;
      }
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['map_of_string_to_list_of_A'][$key15] = $value16;
    }

    if (!array_key_exists('map_of_string_to_set_of_i32', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['map_of_string_to_set_of_i32'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['map_of_string_to_set_of_i32'] as $key19 => $value20) {
      if (!is_string($key19)) {
        return null;
      }
      if (!is_array($value20)) {
        return null;
      }
      $the_set23 = array();
      foreach (/* HH_IGNORE_ERROR[4110] */ $value20 as $key21 => $shape_data22) {
        if (!is_int($shape_data22)) {
          return null;
        }
        $the_set23[$shape_data22] = true;
      }
      $value20 = $the_set23;
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['map_of_string_to_set_of_i32'][$key19] = $value20;
    }

    if (!array_key_exists('map_of_string_to_map_of_string_to_i32', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['map_of_string_to_map_of_string_to_i32'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['map_of_string_to_map_of_string_to_i32'] as $key24 => $value25) {
      if (!is_string($key24)) {
        return null;
      }
      if (!is_array($value25)) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$value25 as $key26 => $value27) {
        if (!is_string($key26)) {
          return null;
        }
        if (!is_int($value27)) {
          return null;
        }
        /* HH_IGNORE_ERROR[4005] */
        $value25[$key26] = $value27;
      }
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['map_of_string_to_map_of_string_to_i32'][$key24] = $value25;
    }

    if (!array_key_exists('map_of_string_to_map_of_string_to_A', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['map_of_string_to_map_of_string_to_A'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['map_of_string_to_map_of_string_to_A'] as $key28 => $value29) {
      if (!is_string($key28)) {
        return null;
      }
      if (!is_array($value29)) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$value29 as $key30 => $value31) {
        if (!is_string($key30)) {
          return null;
        }
        $value31 = \test\fixtures\A::__jsonArrayToShape(/* HH_IGNORE_ERROR[4110] */ $value31);
        if (is_null($value31)) {
          return null;
        }
        /* HH_IGNORE_ERROR[4005] */
        $value29[$key30] = $value31;
      }
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['map_of_string_to_map_of_string_to_A'][$key28] = $value29;
    }

    if (!array_key_exists('list_of_set_of_i32', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['list_of_set_of_i32'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['list_of_set_of_i32'] as $key32 => $value33) {
      if (!is_int($key32)) {
        return null;
      }
      if (!is_array($value33)) {
        return null;
      }
      $the_set36 = array();
      foreach (/* HH_IGNORE_ERROR[4110] */ $value33 as $key34 => $shape_data35) {
        if (!is_int($shape_data35)) {
          return null;
        }
        $the_set36[$shape_data35] = true;
      }
      $value33 = $the_set36;
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['list_of_set_of_i32'][$key32] = $value33;
    }

    if (!array_key_exists('list_of_map_of_string_to_list_of_A', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['list_of_map_of_string_to_list_of_A'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['list_of_map_of_string_to_list_of_A'] as $key37 => $value38) {
      if (!is_int($key37)) {
        return null;
      }
      if (!is_array($value38)) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$value38 as $key39 => $value40) {
        if (!is_string($key39)) {
          return null;
        }
        if (!is_array($value40)) {
          return null;
        }
        foreach (/* HH_IGNORE_ERROR[4110] */$value40 as $key41 => $value42) {
          if (!is_int($key41)) {
            return null;
          }
          $value42 = \test\fixtures\A::__jsonArrayToShape(/* HH_IGNORE_ERROR[4110] */ $value42);
          if (is_null($value42)) {
            return null;
          }
          /* HH_IGNORE_ERROR[4005] */
          $value40[$key41] = $value42;
        }
        /* HH_IGNORE_ERROR[4005] */
        $value38[$key39] = $value40;
      }
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['list_of_map_of_string_to_list_of_A'][$key37] = $value38;
    }

    if (!array_key_exists('list_of_map_of_string_to_A', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['list_of_map_of_string_to_A'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['list_of_map_of_string_to_A'] as $key43 => $value44) {
      if (!is_int($key43)) {
        return null;
      }
      if (!is_array($value44)) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$value44 as $key45 => $value46) {
        if (!is_string($key45)) {
          return null;
        }
        $value46 = \test\fixtures\A::__jsonArrayToShape(/* HH_IGNORE_ERROR[4110] */ $value46);
        if (is_null($value46)) {
          return null;
        }
        /* HH_IGNORE_ERROR[4005] */
        $value44[$key45] = $value46;
      }
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['list_of_map_of_string_to_A'][$key43] = $value44;
    }

    if (!array_key_exists('list_of_self', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['list_of_self'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['list_of_self'] as $key47 => $value48) {
      if (!is_int($key47)) {
        return null;
      }
      $value48 = \test\fixtures\B::__jsonArrayToShape(/* HH_IGNORE_ERROR[4110] */ $value48);
      if (is_null($value48)) {
        return null;
      }
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['list_of_self'][$key47] = $value48;
    }

    if (!array_key_exists('map_of_string_to_self', $shape_data)) {
      return null;
    }
    if (!is_array($shape_data['map_of_string_to_self'])) {
      return null;
    }
    foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['map_of_string_to_self'] as $key49 => $value50) {
      if (!is_string($key49)) {
        return null;
      }
      $value50 = \test\fixtures\B::__jsonArrayToShape(/* HH_IGNORE_ERROR[4110] */ $value50);
      if (is_null($value50)) {
        return null;
      }
      /* HH_IGNORE_ERROR[4005] */
      $shape_data['map_of_string_to_self'][$key49] = $value50;
    }

    if (!array_key_exists('just_an_enum', $shape_data)) {
      $shape_data['just_an_enum'] = null;
    }
    if (!is_int($shape_data['just_an_enum']) && !is_null($shape_data['just_an_enum'])) {
      return null;
    }

    if (!array_key_exists('optional_just_an_A', $shape_data)) {
      $shape_data['optional_just_an_A'] = null;
    }
    if (!is_null($shape_data['optional_just_an_A'])) {
      $shape_data['optional_just_an_A'] = \test\fixtures\A::__jsonArrayToShape(/* HH_IGNORE_ERROR[4110] */ $shape_data['optional_just_an_A']);
      if (is_null($shape_data['optional_just_an_A'])) {
        return null;
      }
    }

    if (!array_key_exists('optional_set_of_i32', $shape_data)) {
      $shape_data['optional_set_of_i32'] = null;
    }
    if (!is_null($shape_data['optional_set_of_i32'])) {
      if (!is_array($shape_data['optional_set_of_i32'])) {
        return null;
      }
      $the_set53 = array();
      foreach (/* HH_IGNORE_ERROR[4110] */ $shape_data['optional_set_of_i32'] as $key51 => $shape_data52) {
        if (!is_int($shape_data52)) {
          return null;
        }
        $the_set53[$shape_data52] = true;
      }
      $shape_data['optional_set_of_i32'] = $the_set53;
    }

    if (!array_key_exists('optional_list_of_i32', $shape_data)) {
      $shape_data['optional_list_of_i32'] = null;
    }
    if (!is_null($shape_data['optional_list_of_i32'])) {
      if (!is_array($shape_data['optional_list_of_i32'])) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['optional_list_of_i32'] as $key54 => $value55) {
        if (!is_int($key54)) {
          return null;
        }
        if (!is_int($value55)) {
          return null;
        }
        /* HH_IGNORE_ERROR[4005] */
        $shape_data['optional_list_of_i32'][$key54] = $value55;
      }
    }

    if (!array_key_exists('optional_list_of_string', $shape_data)) {
      $shape_data['optional_list_of_string'] = null;
    }
    if (!is_null($shape_data['optional_list_of_string'])) {
      if (!is_array($shape_data['optional_list_of_string'])) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['optional_list_of_string'] as $key56 => $value57) {
        if (!is_int($key56)) {
          return null;
        }
        if (!is_string($value57)) {
          return null;
        }
        /* HH_IGNORE_ERROR[4005] */
        $shape_data['optional_list_of_string'][$key56] = $value57;
      }
    }

    if (!array_key_exists('optional_map_of_string_to_i32', $shape_data)) {
      $shape_data['optional_map_of_string_to_i32'] = null;
    }
    if (!is_null($shape_data['optional_map_of_string_to_i32'])) {
      if (!is_array($shape_data['optional_map_of_string_to_i32'])) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['optional_map_of_string_to_i32'] as $key58 => $value59) {
        if (!is_string($key58)) {
          return null;
        }
        if (!is_int($value59)) {
          return null;
        }
        /* HH_IGNORE_ERROR[4005] */
        $shape_data['optional_map_of_string_to_i32'][$key58] = $value59;
      }
    }

    if (!array_key_exists('optional_map_of_string_to_A', $shape_data)) {
      $shape_data['optional_map_of_string_to_A'] = null;
    }
    if (!is_null($shape_data['optional_map_of_string_to_A'])) {
      if (!is_array($shape_data['optional_map_of_string_to_A'])) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['optional_map_of_string_to_A'] as $key60 => $value61) {
        if (!is_string($key60)) {
          return null;
        }
        $value61 = \test\fixtures\A::__jsonArrayToShape(/* HH_IGNORE_ERROR[4110] */ $value61);
        if (is_null($value61)) {
          return null;
        }
        /* HH_IGNORE_ERROR[4005] */
        $shape_data['optional_map_of_string_to_A'][$key60] = $value61;
      }
    }

    if (!array_key_exists('optional_map_of_string_to_list_of_i32', $shape_data)) {
      $shape_data['optional_map_of_string_to_list_of_i32'] = null;
    }
    if (!is_null($shape_data['optional_map_of_string_to_list_of_i32'])) {
      if (!is_array($shape_data['optional_map_of_string_to_list_of_i32'])) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['optional_map_of_string_to_list_of_i32'] as $key62 => $value63) {
        if (!is_string($key62)) {
          return null;
        }
        if (!is_array($value63)) {
          return null;
        }
        foreach (/* HH_IGNORE_ERROR[4110] */$value63 as $key64 => $value65) {
          if (!is_int($key64)) {
            return null;
          }
          if (!is_int($value65)) {
            return null;
          }
          /* HH_IGNORE_ERROR[4005] */
          $value63[$key64] = $value65;
        }
        /* HH_IGNORE_ERROR[4005] */
        $shape_data['optional_map_of_string_to_list_of_i32'][$key62] = $value63;
      }
    }

    if (!array_key_exists('optional_map_of_string_to_list_of_A', $shape_data)) {
      $shape_data['optional_map_of_string_to_list_of_A'] = null;
    }
    if (!is_null($shape_data['optional_map_of_string_to_list_of_A'])) {
      if (!is_array($shape_data['optional_map_of_string_to_list_of_A'])) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['optional_map_of_string_to_list_of_A'] as $key66 => $value67) {
        if (!is_string($key66)) {
          return null;
        }
        if (!is_array($value67)) {
          return null;
        }
        foreach (/* HH_IGNORE_ERROR[4110] */$value67 as $key68 => $value69) {
          if (!is_int($key68)) {
            return null;
          }
          $value69 = \test\fixtures\A::__jsonArrayToShape(/* HH_IGNORE_ERROR[4110] */ $value69);
          if (is_null($value69)) {
            return null;
          }
          /* HH_IGNORE_ERROR[4005] */
          $value67[$key68] = $value69;
        }
        /* HH_IGNORE_ERROR[4005] */
        $shape_data['optional_map_of_string_to_list_of_A'][$key66] = $value67;
      }
    }

    if (!array_key_exists('optional_map_of_string_to_set_of_i32', $shape_data)) {
      $shape_data['optional_map_of_string_to_set_of_i32'] = null;
    }
    if (!is_null($shape_data['optional_map_of_string_to_set_of_i32'])) {
      if (!is_array($shape_data['optional_map_of_string_to_set_of_i32'])) {
        return null;
      }
      foreach (/* HH_IGNORE_ERROR[4110] */$shape_data['optional_map_of_string_to_set_of_i32'] as $key70 => $value71) {
        if (!is_string($key70)) {
          return null;
        }
        if (!is_array($value71)) {
          return null;
        }
        $the_set74 = array();
        foreach (/* HH_IGNORE_ERROR[4110] */ $value71 as $key72 => $shape_data73) {
          if (!is_int($shape_data73)) {
            return null;
          }
          $the_set74[$shape_data73] = true;
        }
        $value71 = $the_set74;
        /* HH_IGNORE_ERROR[4005] */
        $shape_data['optional_map_of_string_to_set_of_i32'][$key70] = $value71;
      }
    }

    if (!array_key_exists('optional_enum', $shape_data)) {
      $shape_data['optional_enum'] = null;
    }
    if (!is_int($shape_data['optional_enum']) && !is_null($shape_data['optional_enum'])) {
      return null;
    }

    return /* HH_IGNORE_ERROR[4110] */ $shape_data;
  }

  public static function __fromShape(self::TShape $shape): this {
    $me = /* HH_IGNORE_ERROR[4060] */ new static();
    $me->just_an_A = $shape['just_an_A'] === null ? null : \test\fixtures\A::__fromShape(nullthrows($shape['just_an_A']));
    $me->set_of_i32 = new Set(array_keys($shape['set_of_i32']));
    $me->list_of_i32 = (new Vector($shape['list_of_i32']));
    $me->list_of_string = (new Vector($shape['list_of_string']));
    $me->map_of_string_to_i32 = (new Map($shape['map_of_string_to_i32']));
    $me->map_of_string_to_A = (new Map($shape['map_of_string_to_A']))->map(
      $val75 ==> \test\fixtures\A::__fromShape($val75),
    );
    $me->map_of_string_to_list_of_i32 = (new Map($shape['map_of_string_to_list_of_i32']))->map(
      $val76 ==> (new Vector($val76)),
    );
    $me->map_of_string_to_list_of_A = (new Map($shape['map_of_string_to_list_of_A']))->map(
      $val77 ==> (new Vector($val77))->map(
        $val78 ==> \test\fixtures\A::__fromShape($val78),
      ),
    );
    $me->map_of_string_to_set_of_i32 = (new Map($shape['map_of_string_to_set_of_i32']))->map(
      $val79 ==> new Set(array_keys($val79)),
    );
    $me->map_of_string_to_map_of_string_to_i32 = (new Map($shape['map_of_string_to_map_of_string_to_i32']))->map(
      $val80 ==> (new Map($val80)),
    );
    $me->map_of_string_to_map_of_string_to_A = (new Map($shape['map_of_string_to_map_of_string_to_A']))->map(
      $val81 ==> (new Map($val81))->map(
        $val82 ==> \test\fixtures\A::__fromShape($val82),
      ),
    );
    $me->list_of_set_of_i32 = (new Vector($shape['list_of_set_of_i32']))->map(
      $val83 ==> new Set(array_keys($val83)),
    );
    $me->list_of_map_of_string_to_list_of_A = (new Vector($shape['list_of_map_of_string_to_list_of_A']))->map(
      $val84 ==> (new Map($val84))->map(
        $val85 ==> (new Vector($val85))->map(
          $val86 ==> \test\fixtures\A::__fromShape($val86),
        ),
      ),
    );
    $me->list_of_map_of_string_to_A = (new Vector($shape['list_of_map_of_string_to_A']))->map(
      $val87 ==> (new Map($val87))->map(
        $val88 ==> \test\fixtures\A::__fromShape($val88),
      ),
    );
    $me->list_of_self = (new Vector($shape['list_of_self']))->map(
      $val89 ==> \test\fixtures\B::__fromShape($val89),
    );
    $me->map_of_string_to_self = (new Map($shape['map_of_string_to_self']))->map(
      $val90 ==> \test\fixtures\B::__fromShape($val90),
    );
    $me->just_an_enum = $shape['just_an_enum'];
    $me->optional_just_an_A = $shape['optional_just_an_A'] === null ? null : \test\fixtures\A::__fromShape(nullthrows($shape['optional_just_an_A']));
    $me->optional_set_of_i32 = $shape['optional_set_of_i32'] === null ? null : new Set(array_keys(nullthrows($shape['optional_set_of_i32'])));
    $me->optional_list_of_i32 = $shape['optional_list_of_i32'] === null ? null : 
      (new Vector($shape['optional_list_of_i32']));
    $me->optional_list_of_string = $shape['optional_list_of_string'] === null ? null : 
      (new Vector($shape['optional_list_of_string']));
    $me->optional_map_of_string_to_i32 = $shape['optional_map_of_string_to_i32'] === null ? null : 
      (new Map($shape['optional_map_of_string_to_i32']));
    $me->optional_map_of_string_to_A = $shape['optional_map_of_string_to_A'] === null ? null : 
      (new Map($shape['optional_map_of_string_to_A']))->map(
        $val91 ==> \test\fixtures\A::__fromShape($val91),
      );
    $me->optional_map_of_string_to_list_of_i32 = $shape['optional_map_of_string_to_list_of_i32'] === null ? null : 
      (new Map($shape['optional_map_of_string_to_list_of_i32']))->map(
        $val92 ==> (new Vector($val92)),
      );
    $me->optional_map_of_string_to_list_of_A = $shape['optional_map_of_string_to_list_of_A'] === null ? null : 
      (new Map($shape['optional_map_of_string_to_list_of_A']))->map(
        $val93 ==> (new Vector($val93))->map(
          $val94 ==> \test\fixtures\A::__fromShape($val94),
        ),
      );
    $me->optional_map_of_string_to_set_of_i32 = $shape['optional_map_of_string_to_set_of_i32'] === null ? null : 
      (new Map($shape['optional_map_of_string_to_set_of_i32']))->map(
        $val95 ==> new Set(array_keys($val95)),
      );
    $me->optional_enum = $shape['optional_enum'];
    return $me;
  }

  public function __toShape(): self::TShape {
    return shape(
      'just_an_A' => $this->just_an_A?->__toShape(),
      'set_of_i32' => array_fill_keys($this->set_of_i32->toValuesArray(), true),
      'list_of_i32' => $this->list_of_i32->toArray(),
      'list_of_string' => $this->list_of_string->toArray(),
      'map_of_string_to_i32' => $this->map_of_string_to_i32->toArray(),
      'map_of_string_to_A' => $this->map_of_string_to_A->map(
        $_val0 ==> $_val0->__toShape(),
      )->toArray(),
      'map_of_string_to_list_of_i32' => $this->map_of_string_to_list_of_i32->map(
        $_val0 ==> $_val0->toArray(),
      )->toArray(),
      'map_of_string_to_list_of_A' => $this->map_of_string_to_list_of_A->map(
        $_val0 ==> $_val0->map(
          $_val1 ==> $_val1->__toShape(),
        )->toArray(),
      )->toArray(),
      'map_of_string_to_set_of_i32' => $this->map_of_string_to_set_of_i32->map(
        $_val0 ==> array_fill_keys($_val0, true),
      )->toArray(),
      'map_of_string_to_map_of_string_to_i32' => $this->map_of_string_to_map_of_string_to_i32->map(
        $_val0 ==> $_val0->toArray(),
      )->toArray(),
      'map_of_string_to_map_of_string_to_A' => $this->map_of_string_to_map_of_string_to_A->map(
        $_val0 ==> $_val0->map(
          $_val1 ==> $_val1->__toShape(),
        )->toArray(),
      )->toArray(),
      'list_of_set_of_i32' => $this->list_of_set_of_i32->map(
        $_val0 ==> array_fill_keys($_val0, true),
      )->toArray(),
      'list_of_map_of_string_to_list_of_A' => $this->list_of_map_of_string_to_list_of_A->map(
        $_val0 ==> $_val0->map(
          $_val1 ==> $_val1->map(
            $_val2 ==> $_val2->__toShape(),
          )->toArray(),
        )->toArray(),
      )->toArray(),
      'list_of_map_of_string_to_A' => $this->list_of_map_of_string_to_A->map(
        $_val0 ==> $_val0->map(
          $_val1 ==> $_val1->__toShape(),
        )->toArray(),
      )->toArray(),
      'list_of_self' => $this->list_of_self->map(
        $_val0 ==> $_val0->__toShape(),
      )->toArray(),
      'map_of_string_to_self' => $this->map_of_string_to_self->map(
        $_val0 ==> $_val0->__toShape(),
      )->toArray(),
      'just_an_enum' => $this->just_an_enum,
      'optional_just_an_A' => $this->optional_just_an_A?->__toShape(),
      'optional_set_of_i32' => $this->optional_set_of_i32 === null ? null : array_fill_keys(nullthrows($this->optional_set_of_i32->toValuesArray()), true),
      'optional_list_of_i32' => $this->optional_list_of_i32?->toArray(),
      'optional_list_of_string' => $this->optional_list_of_string?->toArray(),
      'optional_map_of_string_to_i32' => $this->optional_map_of_string_to_i32?->toArray(),
      'optional_map_of_string_to_A' => $this->optional_map_of_string_to_A?->map(
        $_val0 ==> $_val0->__toShape(),
      )?->toArray(),
      'optional_map_of_string_to_list_of_i32' => $this->optional_map_of_string_to_list_of_i32?->map(
        $_val0 ==> $_val0->toArray(),
      )?->toArray(),
      'optional_map_of_string_to_list_of_A' => $this->optional_map_of_string_to_list_of_A?->map(
        $_val0 ==> $_val0->map(
          $_val1 ==> $_val1->__toShape(),
        )->toArray(),
      )?->toArray(),
      'optional_map_of_string_to_set_of_i32' => $this->optional_map_of_string_to_set_of_i32?->map(
        $_val0 ==> array_fill_keys($_val0, true),
      )?->toArray(),
      'optional_enum' => $this->optional_enum,
    );
  }
  public function read(\TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == \TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == \TType::STRUCT) {
            $this->just_an_A = new \test\fixtures\A();
            $xfer += $this->just_an_A->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == \TType::SET) {
            $_size1 = 0;
            $_etype4 = 0;
            $_val0 = Set{};
            $xfer += $input->readSetBegin($_etype4, $_size1);
            for ($_i5 = 0; $_size1 === null || $_i5 < $_size1; ++$_i5)
            {
              if ($_size1 === null && !$input->readSetHasNext()) {
                break;
              }
              $elem6 = null;
              $xfer += $input->readI32($elem6);
              if ($elem6 !== null) {
                $_val0->add($elem6);
              }
            }
            $xfer += $input->readSetEnd();
            $this->set_of_i32 = $_val0;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == \TType::LST) {
            $_size8 = 0;
            $_val7 = Vector {};
            $_etype11 = 0;
            $xfer += $input->readListBegin($_etype11, $_size8);
            for ($_i12 = 0; $_size8 === null || $_i12 < $_size8; ++$_i12)
            {
              if ($_size8 === null && !$input->readListHasNext()) {
                break;
              }
              $elem13 = null;
              $xfer += $input->readI32($elem13);
              if ($elem13 !== null) {
                $_val7 []= $elem13;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_i32 = $_val7;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == \TType::LST) {
            $_size15 = 0;
            $_val14 = Vector {};
            $_etype18 = 0;
            $xfer += $input->readListBegin($_etype18, $_size15);
            for ($_i19 = 0; $_size15 === null || $_i19 < $_size15; ++$_i19)
            {
              if ($_size15 === null && !$input->readListHasNext()) {
                break;
              }
              $elem20 = null;
              $xfer += $input->readString($elem20);
              if ($elem20 !== null) {
                $_val14 []= $elem20;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_string = $_val14;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == \TType::MAP) {
            $_size22 = 0;
            $_val21 = Map {};
            $_ktype23 = 0;
            $_vtype24 = 0;
            $xfer += $input->readMapBegin($_ktype23, $_vtype24, $_size22);
            for ($_i26 = 0; $_size22 === null || $_i26 < $_size22; ++$_i26)
            {
              if ($_size22 === null && !$input->readMapHasNext()) {
                break;
              }
              $key27 = null;
              $xfer += $input->readString($key27);
              $val28 = null;
              $xfer += $input->readI32($val28);
              if ($key27 !== null && $val28 !== null) {
                $_val21[$key27] = $val28;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_i32 = $_val21;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == \TType::MAP) {
            $_size30 = 0;
            $_val29 = Map {};
            $_ktype31 = 0;
            $_vtype32 = 0;
            $xfer += $input->readMapBegin($_ktype31, $_vtype32, $_size30);
            for ($_i34 = 0; $_size30 === null || $_i34 < $_size30; ++$_i34)
            {
              if ($_size30 === null && !$input->readMapHasNext()) {
                break;
              }
              $key35 = null;
              $xfer += $input->readString($key35);
              $val36 = new \test\fixtures\A();
              $xfer += $val36->read($input);
              if ($key35 !== null && $val36 !== null) {
                $_val29[$key35] = $val36;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_A = $_val29;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == \TType::MAP) {
            $_size38 = 0;
            $_val37 = Map {};
            $_ktype39 = 0;
            $_vtype40 = 0;
            $xfer += $input->readMapBegin($_ktype39, $_vtype40, $_size38);
            for ($_i42 = 0; $_size38 === null || $_i42 < $_size38; ++$_i42)
            {
              if ($_size38 === null && !$input->readMapHasNext()) {
                break;
              }
              $key43 = null;
              $xfer += $input->readString($key43);
              $_size46 = 0;
              $_val45 = Vector {};
              $_etype49 = 0;
              $xfer += $input->readListBegin($_etype49, $_size46);
              for ($_i50 = 0; $_size46 === null || $_i50 < $_size46; ++$_i50)
              {
                if ($_size46 === null && !$input->readListHasNext()) {
                  break;
                }
                $elem51 = null;
                $xfer += $input->readI32($elem51);
                if ($elem51 !== null) {
                  $_val45 []= $elem51;
                }
              }
              $xfer += $input->readListEnd();
              $val44 = $_val45;
              if ($key43 !== null && $val44 !== null) {
                $_val37[$key43] = $val44;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_list_of_i32 = $_val37;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == \TType::MAP) {
            $_size53 = 0;
            $_val52 = Map {};
            $_ktype54 = 0;
            $_vtype55 = 0;
            $xfer += $input->readMapBegin($_ktype54, $_vtype55, $_size53);
            for ($_i57 = 0; $_size53 === null || $_i57 < $_size53; ++$_i57)
            {
              if ($_size53 === null && !$input->readMapHasNext()) {
                break;
              }
              $key58 = null;
              $xfer += $input->readString($key58);
              $_size61 = 0;
              $_val60 = Vector {};
              $_etype64 = 0;
              $xfer += $input->readListBegin($_etype64, $_size61);
              for ($_i65 = 0; $_size61 === null || $_i65 < $_size61; ++$_i65)
              {
                if ($_size61 === null && !$input->readListHasNext()) {
                  break;
                }
                $elem66 = new \test\fixtures\A();
                $xfer += $elem66->read($input);
                if ($elem66 !== null) {
                  $_val60 []= $elem66;
                }
              }
              $xfer += $input->readListEnd();
              $val59 = $_val60;
              if ($key58 !== null && $val59 !== null) {
                $_val52[$key58] = $val59;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_list_of_A = $_val52;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == \TType::MAP) {
            $_size68 = 0;
            $_val67 = Map {};
            $_ktype69 = 0;
            $_vtype70 = 0;
            $xfer += $input->readMapBegin($_ktype69, $_vtype70, $_size68);
            for ($_i72 = 0; $_size68 === null || $_i72 < $_size68; ++$_i72)
            {
              if ($_size68 === null && !$input->readMapHasNext()) {
                break;
              }
              $key73 = null;
              $xfer += $input->readString($key73);
              $_size76 = 0;
              $_etype79 = 0;
              $_val75 = Set{};
              $xfer += $input->readSetBegin($_etype79, $_size76);
              for ($_i80 = 0; $_size76 === null || $_i80 < $_size76; ++$_i80)
              {
                if ($_size76 === null && !$input->readSetHasNext()) {
                  break;
                }
                $elem81 = null;
                $xfer += $input->readI32($elem81);
                if ($elem81 !== null) {
                  $_val75->add($elem81);
                }
              }
              $xfer += $input->readSetEnd();
              $val74 = $_val75;
              if ($key73 !== null && $val74 !== null) {
                $_val67[$key73] = $val74;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_set_of_i32 = $_val67;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == \TType::MAP) {
            $_size83 = 0;
            $_val82 = Map {};
            $_ktype84 = 0;
            $_vtype85 = 0;
            $xfer += $input->readMapBegin($_ktype84, $_vtype85, $_size83);
            for ($_i87 = 0; $_size83 === null || $_i87 < $_size83; ++$_i87)
            {
              if ($_size83 === null && !$input->readMapHasNext()) {
                break;
              }
              $key88 = null;
              $xfer += $input->readString($key88);
              $_size91 = 0;
              $_val90 = Map {};
              $_ktype92 = 0;
              $_vtype93 = 0;
              $xfer += $input->readMapBegin($_ktype92, $_vtype93, $_size91);
              for ($_i95 = 0; $_size91 === null || $_i95 < $_size91; ++$_i95)
              {
                if ($_size91 === null && !$input->readMapHasNext()) {
                  break;
                }
                $key96 = null;
                $xfer += $input->readString($key96);
                $val97 = null;
                $xfer += $input->readI32($val97);
                if ($key96 !== null && $val97 !== null) {
                  $_val90[$key96] = $val97;
                }
              }
              $xfer += $input->readMapEnd();
              $val89 = $_val90;
              if ($key88 !== null && $val89 !== null) {
                $_val82[$key88] = $val89;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_map_of_string_to_i32 = $_val82;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == \TType::MAP) {
            $_size99 = 0;
            $_val98 = Map {};
            $_ktype100 = 0;
            $_vtype101 = 0;
            $xfer += $input->readMapBegin($_ktype100, $_vtype101, $_size99);
            for ($_i103 = 0; $_size99 === null || $_i103 < $_size99; ++$_i103)
            {
              if ($_size99 === null && !$input->readMapHasNext()) {
                break;
              }
              $key104 = null;
              $xfer += $input->readString($key104);
              $_size107 = 0;
              $_val106 = Map {};
              $_ktype108 = 0;
              $_vtype109 = 0;
              $xfer += $input->readMapBegin($_ktype108, $_vtype109, $_size107);
              for ($_i111 = 0; $_size107 === null || $_i111 < $_size107; ++$_i111)
              {
                if ($_size107 === null && !$input->readMapHasNext()) {
                  break;
                }
                $key112 = null;
                $xfer += $input->readString($key112);
                $val113 = new \test\fixtures\A();
                $xfer += $val113->read($input);
                if ($key112 !== null && $val113 !== null) {
                  $_val106[$key112] = $val113;
                }
              }
              $xfer += $input->readMapEnd();
              $val105 = $_val106;
              if ($key104 !== null && $val105 !== null) {
                $_val98[$key104] = $val105;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_map_of_string_to_A = $_val98;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == \TType::LST) {
            $_size115 = 0;
            $_val114 = Vector {};
            $_etype118 = 0;
            $xfer += $input->readListBegin($_etype118, $_size115);
            for ($_i119 = 0; $_size115 === null || $_i119 < $_size115; ++$_i119)
            {
              if ($_size115 === null && !$input->readListHasNext()) {
                break;
              }
              $_size122 = 0;
              $_etype125 = 0;
              $_val121 = Set{};
              $xfer += $input->readSetBegin($_etype125, $_size122);
              for ($_i126 = 0; $_size122 === null || $_i126 < $_size122; ++$_i126)
              {
                if ($_size122 === null && !$input->readSetHasNext()) {
                  break;
                }
                $elem127 = null;
                $xfer += $input->readI32($elem127);
                if ($elem127 !== null) {
                  $_val121->add($elem127);
                }
              }
              $xfer += $input->readSetEnd();
              $elem120 = $_val121;
              if ($elem120 !== null) {
                $_val114 []= $elem120;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_set_of_i32 = $_val114;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == \TType::LST) {
            $_size129 = 0;
            $_val128 = Vector {};
            $_etype132 = 0;
            $xfer += $input->readListBegin($_etype132, $_size129);
            for ($_i133 = 0; $_size129 === null || $_i133 < $_size129; ++$_i133)
            {
              if ($_size129 === null && !$input->readListHasNext()) {
                break;
              }
              $_size136 = 0;
              $_val135 = Map {};
              $_ktype137 = 0;
              $_vtype138 = 0;
              $xfer += $input->readMapBegin($_ktype137, $_vtype138, $_size136);
              for ($_i140 = 0; $_size136 === null || $_i140 < $_size136; ++$_i140)
              {
                if ($_size136 === null && !$input->readMapHasNext()) {
                  break;
                }
                $key141 = null;
                $xfer += $input->readString($key141);
                $_size144 = 0;
                $_val143 = Vector {};
                $_etype147 = 0;
                $xfer += $input->readListBegin($_etype147, $_size144);
                for ($_i148 = 0; $_size144 === null || $_i148 < $_size144; ++$_i148)
                {
                  if ($_size144 === null && !$input->readListHasNext()) {
                    break;
                  }
                  $elem149 = new \test\fixtures\A();
                  $xfer += $elem149->read($input);
                  if ($elem149 !== null) {
                    $_val143 []= $elem149;
                  }
                }
                $xfer += $input->readListEnd();
                $val142 = $_val143;
                if ($key141 !== null && $val142 !== null) {
                  $_val135[$key141] = $val142;
                }
              }
              $xfer += $input->readMapEnd();
              $elem134 = $_val135;
              if ($elem134 !== null) {
                $_val128 []= $elem134;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_map_of_string_to_list_of_A = $_val128;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == \TType::LST) {
            $_size151 = 0;
            $_val150 = Vector {};
            $_etype154 = 0;
            $xfer += $input->readListBegin($_etype154, $_size151);
            for ($_i155 = 0; $_size151 === null || $_i155 < $_size151; ++$_i155)
            {
              if ($_size151 === null && !$input->readListHasNext()) {
                break;
              }
              $_size158 = 0;
              $_val157 = Map {};
              $_ktype159 = 0;
              $_vtype160 = 0;
              $xfer += $input->readMapBegin($_ktype159, $_vtype160, $_size158);
              for ($_i162 = 0; $_size158 === null || $_i162 < $_size158; ++$_i162)
              {
                if ($_size158 === null && !$input->readMapHasNext()) {
                  break;
                }
                $key163 = null;
                $xfer += $input->readString($key163);
                $val164 = new \test\fixtures\A();
                $xfer += $val164->read($input);
                if ($key163 !== null && $val164 !== null) {
                  $_val157[$key163] = $val164;
                }
              }
              $xfer += $input->readMapEnd();
              $elem156 = $_val157;
              if ($elem156 !== null) {
                $_val150 []= $elem156;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_map_of_string_to_A = $_val150;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == \TType::LST) {
            $_size166 = 0;
            $_val165 = Vector {};
            $_etype169 = 0;
            $xfer += $input->readListBegin($_etype169, $_size166);
            for ($_i170 = 0; $_size166 === null || $_i170 < $_size166; ++$_i170)
            {
              if ($_size166 === null && !$input->readListHasNext()) {
                break;
              }
              $elem171 = new \test\fixtures\B();
              $xfer += $elem171->read($input);
              if ($elem171 !== null) {
                $_val165 []= $elem171;
              }
            }
            $xfer += $input->readListEnd();
            $this->list_of_self = $_val165;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == \TType::MAP) {
            $_size173 = 0;
            $_val172 = Map {};
            $_ktype174 = 0;
            $_vtype175 = 0;
            $xfer += $input->readMapBegin($_ktype174, $_vtype175, $_size173);
            for ($_i177 = 0; $_size173 === null || $_i177 < $_size173; ++$_i177)
            {
              if ($_size173 === null && !$input->readMapHasNext()) {
                break;
              }
              $key178 = null;
              $xfer += $input->readString($key178);
              $val179 = new \test\fixtures\B();
              $xfer += $val179->read($input);
              if ($key178 !== null && $val179 !== null) {
                $_val172[$key178] = $val179;
              }
            }
            $xfer += $input->readMapEnd();
            $this->map_of_string_to_self = $_val172;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 17:
          if ($ftype == \TType::I32) {
            $_val180 = null;
            $xfer += $input->readI32($_val180);
            $this->just_an_enum = \test\fixtures\Enum::coerce($_val180);

          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 51:
          if ($ftype == \TType::STRUCT) {
            $this->optional_just_an_A = new \test\fixtures\A();
            $xfer += $this->optional_just_an_A->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 52:
          if ($ftype == \TType::SET) {
            $_size182 = 0;
            $_etype185 = 0;
            $_val181 = Set{};
            $xfer += $input->readSetBegin($_etype185, $_size182);
            for ($_i186 = 0; $_size182 === null || $_i186 < $_size182; ++$_i186)
            {
              if ($_size182 === null && !$input->readSetHasNext()) {
                break;
              }
              $elem187 = null;
              $xfer += $input->readI32($elem187);
              if ($elem187 !== null) {
                $_val181->add($elem187);
              }
            }
            $xfer += $input->readSetEnd();
            $this->optional_set_of_i32 = $_val181;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 53:
          if ($ftype == \TType::LST) {
            $_size189 = 0;
            $_val188 = Vector {};
            $_etype192 = 0;
            $xfer += $input->readListBegin($_etype192, $_size189);
            for ($_i193 = 0; $_size189 === null || $_i193 < $_size189; ++$_i193)
            {
              if ($_size189 === null && !$input->readListHasNext()) {
                break;
              }
              $elem194 = null;
              $xfer += $input->readI32($elem194);
              if ($elem194 !== null) {
                $_val188 []= $elem194;
              }
            }
            $xfer += $input->readListEnd();
            $this->optional_list_of_i32 = $_val188;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 54:
          if ($ftype == \TType::LST) {
            $_size196 = 0;
            $_val195 = Vector {};
            $_etype199 = 0;
            $xfer += $input->readListBegin($_etype199, $_size196);
            for ($_i200 = 0; $_size196 === null || $_i200 < $_size196; ++$_i200)
            {
              if ($_size196 === null && !$input->readListHasNext()) {
                break;
              }
              $elem201 = null;
              $xfer += $input->readString($elem201);
              if ($elem201 !== null) {
                $_val195 []= $elem201;
              }
            }
            $xfer += $input->readListEnd();
            $this->optional_list_of_string = $_val195;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 55:
          if ($ftype == \TType::MAP) {
            $_size203 = 0;
            $_val202 = Map {};
            $_ktype204 = 0;
            $_vtype205 = 0;
            $xfer += $input->readMapBegin($_ktype204, $_vtype205, $_size203);
            for ($_i207 = 0; $_size203 === null || $_i207 < $_size203; ++$_i207)
            {
              if ($_size203 === null && !$input->readMapHasNext()) {
                break;
              }
              $key208 = null;
              $xfer += $input->readString($key208);
              $val209 = null;
              $xfer += $input->readI32($val209);
              if ($key208 !== null && $val209 !== null) {
                $_val202[$key208] = $val209;
              }
            }
            $xfer += $input->readMapEnd();
            $this->optional_map_of_string_to_i32 = $_val202;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 56:
          if ($ftype == \TType::MAP) {
            $_size211 = 0;
            $_val210 = Map {};
            $_ktype212 = 0;
            $_vtype213 = 0;
            $xfer += $input->readMapBegin($_ktype212, $_vtype213, $_size211);
            for ($_i215 = 0; $_size211 === null || $_i215 < $_size211; ++$_i215)
            {
              if ($_size211 === null && !$input->readMapHasNext()) {
                break;
              }
              $key216 = null;
              $xfer += $input->readString($key216);
              $val217 = new \test\fixtures\A();
              $xfer += $val217->read($input);
              if ($key216 !== null && $val217 !== null) {
                $_val210[$key216] = $val217;
              }
            }
            $xfer += $input->readMapEnd();
            $this->optional_map_of_string_to_A = $_val210;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 57:
          if ($ftype == \TType::MAP) {
            $_size219 = 0;
            $_val218 = Map {};
            $_ktype220 = 0;
            $_vtype221 = 0;
            $xfer += $input->readMapBegin($_ktype220, $_vtype221, $_size219);
            for ($_i223 = 0; $_size219 === null || $_i223 < $_size219; ++$_i223)
            {
              if ($_size219 === null && !$input->readMapHasNext()) {
                break;
              }
              $key224 = null;
              $xfer += $input->readString($key224);
              $_size227 = 0;
              $_val226 = Vector {};
              $_etype230 = 0;
              $xfer += $input->readListBegin($_etype230, $_size227);
              for ($_i231 = 0; $_size227 === null || $_i231 < $_size227; ++$_i231)
              {
                if ($_size227 === null && !$input->readListHasNext()) {
                  break;
                }
                $elem232 = null;
                $xfer += $input->readI32($elem232);
                if ($elem232 !== null) {
                  $_val226 []= $elem232;
                }
              }
              $xfer += $input->readListEnd();
              $val225 = $_val226;
              if ($key224 !== null && $val225 !== null) {
                $_val218[$key224] = $val225;
              }
            }
            $xfer += $input->readMapEnd();
            $this->optional_map_of_string_to_list_of_i32 = $_val218;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 58:
          if ($ftype == \TType::MAP) {
            $_size234 = 0;
            $_val233 = Map {};
            $_ktype235 = 0;
            $_vtype236 = 0;
            $xfer += $input->readMapBegin($_ktype235, $_vtype236, $_size234);
            for ($_i238 = 0; $_size234 === null || $_i238 < $_size234; ++$_i238)
            {
              if ($_size234 === null && !$input->readMapHasNext()) {
                break;
              }
              $key239 = null;
              $xfer += $input->readString($key239);
              $_size242 = 0;
              $_val241 = Vector {};
              $_etype245 = 0;
              $xfer += $input->readListBegin($_etype245, $_size242);
              for ($_i246 = 0; $_size242 === null || $_i246 < $_size242; ++$_i246)
              {
                if ($_size242 === null && !$input->readListHasNext()) {
                  break;
                }
                $elem247 = new \test\fixtures\A();
                $xfer += $elem247->read($input);
                if ($elem247 !== null) {
                  $_val241 []= $elem247;
                }
              }
              $xfer += $input->readListEnd();
              $val240 = $_val241;
              if ($key239 !== null && $val240 !== null) {
                $_val233[$key239] = $val240;
              }
            }
            $xfer += $input->readMapEnd();
            $this->optional_map_of_string_to_list_of_A = $_val233;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 59:
          if ($ftype == \TType::MAP) {
            $_size249 = 0;
            $_val248 = Map {};
            $_ktype250 = 0;
            $_vtype251 = 0;
            $xfer += $input->readMapBegin($_ktype250, $_vtype251, $_size249);
            for ($_i253 = 0; $_size249 === null || $_i253 < $_size249; ++$_i253)
            {
              if ($_size249 === null && !$input->readMapHasNext()) {
                break;
              }
              $key254 = null;
              $xfer += $input->readString($key254);
              $_size257 = 0;
              $_etype260 = 0;
              $_val256 = Set{};
              $xfer += $input->readSetBegin($_etype260, $_size257);
              for ($_i261 = 0; $_size257 === null || $_i261 < $_size257; ++$_i261)
              {
                if ($_size257 === null && !$input->readSetHasNext()) {
                  break;
                }
                $elem262 = null;
                $xfer += $input->readI32($elem262);
                if ($elem262 !== null) {
                  $_val256->add($elem262);
                }
              }
              $xfer += $input->readSetEnd();
              $val255 = $_val256;
              if ($key254 !== null && $val255 !== null) {
                $_val248[$key254] = $val255;
              }
            }
            $xfer += $input->readMapEnd();
            $this->optional_map_of_string_to_set_of_i32 = $_val248;
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 60:
          if ($ftype == \TType::I32) {
            $_val263 = null;
            $xfer += $input->readI32($_val263);
            $this->optional_enum = \test\fixtures\Enum::coerce($_val263);

          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(\TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('B');
    if ($this->just_an_A !== null) {
      $_val0 = $this->just_an_A;
      if (!($_val0 instanceof \test\fixtures\A)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('just_an_A', \TType::STRUCT, 1);
      $xfer += $_val0->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->set_of_i32 !== null) {
      $_val1 = $this->set_of_i32;
      if (!($_val1 instanceof Set)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('set_of_i32', \TType::SET, 2);
      $output->writeSetBegin(\TType::I32, count($_val1));
      if ($_val1 !== null)
      {
        foreach ($_val1 as $iter2)
        {
          $xfer += $output->writeI32($iter2);
        }
      }
      $output->writeSetEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_i32 !== null) {
      $_val3 = $this->list_of_i32;
      if (!($_val3 instanceof \Indexish) && !(($_val3 instanceof \Iterator || $_val3 instanceof \IteratorAggregate) && $_val3 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_i32', \TType::LST, 3);
      $output->writeListBegin(\TType::I32, count($_val3));
      if ($_val3 !== null)
      {
        foreach ($_val3 as $iter4)
        {
          $xfer += $output->writeI32($iter4);
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_string !== null) {
      $_val5 = $this->list_of_string;
      if (!($_val5 instanceof \Indexish) && !(($_val5 instanceof \Iterator || $_val5 instanceof \IteratorAggregate) && $_val5 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_string', \TType::LST, 4);
      $output->writeListBegin(\TType::STRING, count($_val5));
      if ($_val5 !== null)
      {
        foreach ($_val5 as $iter6)
        {
          $xfer += $output->writeString($iter6);
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_i32 !== null) {
      $_val7 = $this->map_of_string_to_i32;
      if (!($_val7 instanceof \Indexish) && !(($_val7 instanceof \Iterator || $_val7 instanceof \IteratorAggregate) && $_val7 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_i32', \TType::MAP, 5);
      $output->writeMapBegin(\TType::STRING, \TType::I32, count($_val7));
      if ($_val7 !== null)
      {
        foreach ($_val7 as $kiter8 => $viter9)
        {
          $xfer += $output->writeString($kiter8);
          $xfer += $output->writeI32($viter9);
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_A !== null) {
      $_val10 = $this->map_of_string_to_A;
      if (!($_val10 instanceof \Indexish) && !(($_val10 instanceof \Iterator || $_val10 instanceof \IteratorAggregate) && $_val10 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_A', \TType::MAP, 6);
      $output->writeMapBegin(\TType::STRING, \TType::STRUCT, count($_val10));
      if ($_val10 !== null)
      {
        foreach ($_val10 as $kiter11 => $viter12)
        {
          $xfer += $output->writeString($kiter11);
          $xfer += $viter12->write($output);
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_list_of_i32 !== null) {
      $_val13 = $this->map_of_string_to_list_of_i32;
      if (!($_val13 instanceof \Indexish) && !(($_val13 instanceof \Iterator || $_val13 instanceof \IteratorAggregate) && $_val13 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_list_of_i32', \TType::MAP, 7);
      $output->writeMapBegin(\TType::STRING, \TType::LST, count($_val13));
      if ($_val13 !== null)
      {
        foreach ($_val13 as $kiter14 => $viter15)
        {
          $xfer += $output->writeString($kiter14);
          $output->writeListBegin(\TType::I32, count($viter15));
          if ($viter15 !== null)
          {
            foreach ($viter15 as $iter16)
            {
              $xfer += $output->writeI32($iter16);
            }
          }
          $output->writeListEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_list_of_A !== null) {
      $_val17 = $this->map_of_string_to_list_of_A;
      if (!($_val17 instanceof \Indexish) && !(($_val17 instanceof \Iterator || $_val17 instanceof \IteratorAggregate) && $_val17 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_list_of_A', \TType::MAP, 8);
      $output->writeMapBegin(\TType::STRING, \TType::LST, count($_val17));
      if ($_val17 !== null)
      {
        foreach ($_val17 as $kiter18 => $viter19)
        {
          $xfer += $output->writeString($kiter18);
          $output->writeListBegin(\TType::STRUCT, count($viter19));
          if ($viter19 !== null)
          {
            foreach ($viter19 as $iter20)
            {
              $xfer += $iter20->write($output);
            }
          }
          $output->writeListEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_set_of_i32 !== null) {
      $_val21 = $this->map_of_string_to_set_of_i32;
      if (!($_val21 instanceof \Indexish) && !(($_val21 instanceof \Iterator || $_val21 instanceof \IteratorAggregate) && $_val21 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_set_of_i32', \TType::MAP, 9);
      $output->writeMapBegin(\TType::STRING, \TType::SET, count($_val21));
      if ($_val21 !== null)
      {
        foreach ($_val21 as $kiter22 => $viter23)
        {
          $xfer += $output->writeString($kiter22);
          $output->writeSetBegin(\TType::I32, count($viter23));
          if ($viter23 !== null)
          {
            foreach ($viter23 as $iter24)
            {
              $xfer += $output->writeI32($iter24);
            }
          }
          $output->writeSetEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_map_of_string_to_i32 !== null) {
      $_val25 = $this->map_of_string_to_map_of_string_to_i32;
      if (!($_val25 instanceof \Indexish) && !(($_val25 instanceof \Iterator || $_val25 instanceof \IteratorAggregate) && $_val25 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_map_of_string_to_i32', \TType::MAP, 10);
      $output->writeMapBegin(\TType::STRING, \TType::MAP, count($_val25));
      if ($_val25 !== null)
      {
        foreach ($_val25 as $kiter26 => $viter27)
        {
          $xfer += $output->writeString($kiter26);
          $output->writeMapBegin(\TType::STRING, \TType::I32, count($viter27));
          if ($viter27 !== null)
          {
            foreach ($viter27 as $kiter28 => $viter29)
            {
              $xfer += $output->writeString($kiter28);
              $xfer += $output->writeI32($viter29);
            }
          }
          $output->writeMapEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_map_of_string_to_A !== null) {
      $_val30 = $this->map_of_string_to_map_of_string_to_A;
      if (!($_val30 instanceof \Indexish) && !(($_val30 instanceof \Iterator || $_val30 instanceof \IteratorAggregate) && $_val30 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_map_of_string_to_A', \TType::MAP, 11);
      $output->writeMapBegin(\TType::STRING, \TType::MAP, count($_val30));
      if ($_val30 !== null)
      {
        foreach ($_val30 as $kiter31 => $viter32)
        {
          $xfer += $output->writeString($kiter31);
          $output->writeMapBegin(\TType::STRING, \TType::STRUCT, count($viter32));
          if ($viter32 !== null)
          {
            foreach ($viter32 as $kiter33 => $viter34)
            {
              $xfer += $output->writeString($kiter33);
              $xfer += $viter34->write($output);
            }
          }
          $output->writeMapEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_set_of_i32 !== null) {
      $_val35 = $this->list_of_set_of_i32;
      if (!($_val35 instanceof \Indexish) && !(($_val35 instanceof \Iterator || $_val35 instanceof \IteratorAggregate) && $_val35 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_set_of_i32', \TType::LST, 12);
      $output->writeListBegin(\TType::SET, count($_val35));
      if ($_val35 !== null)
      {
        foreach ($_val35 as $iter36)
        {
          $output->writeSetBegin(\TType::I32, count($iter36));
          if ($iter36 !== null)
          {
            foreach ($iter36 as $iter37)
            {
              $xfer += $output->writeI32($iter37);
            }
          }
          $output->writeSetEnd();
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_map_of_string_to_list_of_A !== null) {
      $_val38 = $this->list_of_map_of_string_to_list_of_A;
      if (!($_val38 instanceof \Indexish) && !(($_val38 instanceof \Iterator || $_val38 instanceof \IteratorAggregate) && $_val38 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_map_of_string_to_list_of_A', \TType::LST, 13);
      $output->writeListBegin(\TType::MAP, count($_val38));
      if ($_val38 !== null)
      {
        foreach ($_val38 as $iter39)
        {
          $output->writeMapBegin(\TType::STRING, \TType::LST, count($iter39));
          if ($iter39 !== null)
          {
            foreach ($iter39 as $kiter40 => $viter41)
            {
              $xfer += $output->writeString($kiter40);
              $output->writeListBegin(\TType::STRUCT, count($viter41));
              if ($viter41 !== null)
              {
                foreach ($viter41 as $iter42)
                {
                  $xfer += $iter42->write($output);
                }
              }
              $output->writeListEnd();
            }
          }
          $output->writeMapEnd();
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_map_of_string_to_A !== null) {
      $_val43 = $this->list_of_map_of_string_to_A;
      if (!($_val43 instanceof \Indexish) && !(($_val43 instanceof \Iterator || $_val43 instanceof \IteratorAggregate) && $_val43 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_map_of_string_to_A', \TType::LST, 14);
      $output->writeListBegin(\TType::MAP, count($_val43));
      if ($_val43 !== null)
      {
        foreach ($_val43 as $iter44)
        {
          $output->writeMapBegin(\TType::STRING, \TType::STRUCT, count($iter44));
          if ($iter44 !== null)
          {
            foreach ($iter44 as $kiter45 => $viter46)
            {
              $xfer += $output->writeString($kiter45);
              $xfer += $viter46->write($output);
            }
          }
          $output->writeMapEnd();
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_of_self !== null) {
      $_val47 = $this->list_of_self;
      if (!($_val47 instanceof \Indexish) && !(($_val47 instanceof \Iterator || $_val47 instanceof \IteratorAggregate) && $_val47 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_of_self', \TType::LST, 15);
      $output->writeListBegin(\TType::STRUCT, count($_val47));
      if ($_val47 !== null)
      {
        foreach ($_val47 as $iter48)
        {
          $xfer += $iter48->write($output);
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_of_string_to_self !== null) {
      $_val49 = $this->map_of_string_to_self;
      if (!($_val49 instanceof \Indexish) && !(($_val49 instanceof \Iterator || $_val49 instanceof \IteratorAggregate) && $_val49 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_of_string_to_self', \TType::MAP, 16);
      $output->writeMapBegin(\TType::STRING, \TType::STRUCT, count($_val49));
      if ($_val49 !== null)
      {
        foreach ($_val49 as $kiter50 => $viter51)
        {
          $xfer += $output->writeString($kiter50);
          $xfer += $viter51->write($output);
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->just_an_enum !== null) {
      $_val52 = \test\fixtures\Enum::assert($this->just_an_enum);
      $xfer += $output->writeFieldBegin('just_an_enum', \TType::I32, 17);
      $xfer += $output->writeI32($_val52);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_just_an_A !== null) {
      $_val53 = $this->optional_just_an_A;
      if (!($_val53 instanceof \test\fixtures\A)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_just_an_A', \TType::STRUCT, 51);
      $xfer += $_val53->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_set_of_i32 !== null) {
      $_val54 = $this->optional_set_of_i32;
      if (!($_val54 instanceof Set)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_set_of_i32', \TType::SET, 52);
      $output->writeSetBegin(\TType::I32, count($_val54));
      if ($_val54 !== null)
      {
        foreach ($_val54 as $iter55)
        {
          $xfer += $output->writeI32($iter55);
        }
      }
      $output->writeSetEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_list_of_i32 !== null) {
      $_val56 = $this->optional_list_of_i32;
      if (!($_val56 instanceof \Indexish) && !(($_val56 instanceof \Iterator || $_val56 instanceof \IteratorAggregate) && $_val56 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_list_of_i32', \TType::LST, 53);
      $output->writeListBegin(\TType::I32, count($_val56));
      if ($_val56 !== null)
      {
        foreach ($_val56 as $iter57)
        {
          $xfer += $output->writeI32($iter57);
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_list_of_string !== null) {
      $_val58 = $this->optional_list_of_string;
      if (!($_val58 instanceof \Indexish) && !(($_val58 instanceof \Iterator || $_val58 instanceof \IteratorAggregate) && $_val58 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_list_of_string', \TType::LST, 54);
      $output->writeListBegin(\TType::STRING, count($_val58));
      if ($_val58 !== null)
      {
        foreach ($_val58 as $iter59)
        {
          $xfer += $output->writeString($iter59);
        }
      }
      $output->writeListEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_map_of_string_to_i32 !== null) {
      $_val60 = $this->optional_map_of_string_to_i32;
      if (!($_val60 instanceof \Indexish) && !(($_val60 instanceof \Iterator || $_val60 instanceof \IteratorAggregate) && $_val60 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_map_of_string_to_i32', \TType::MAP, 55);
      $output->writeMapBegin(\TType::STRING, \TType::I32, count($_val60));
      if ($_val60 !== null)
      {
        foreach ($_val60 as $kiter61 => $viter62)
        {
          $xfer += $output->writeString($kiter61);
          $xfer += $output->writeI32($viter62);
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_map_of_string_to_A !== null) {
      $_val63 = $this->optional_map_of_string_to_A;
      if (!($_val63 instanceof \Indexish) && !(($_val63 instanceof \Iterator || $_val63 instanceof \IteratorAggregate) && $_val63 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_map_of_string_to_A', \TType::MAP, 56);
      $output->writeMapBegin(\TType::STRING, \TType::STRUCT, count($_val63));
      if ($_val63 !== null)
      {
        foreach ($_val63 as $kiter64 => $viter65)
        {
          $xfer += $output->writeString($kiter64);
          $xfer += $viter65->write($output);
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_map_of_string_to_list_of_i32 !== null) {
      $_val66 = $this->optional_map_of_string_to_list_of_i32;
      if (!($_val66 instanceof \Indexish) && !(($_val66 instanceof \Iterator || $_val66 instanceof \IteratorAggregate) && $_val66 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_map_of_string_to_list_of_i32', \TType::MAP, 57);
      $output->writeMapBegin(\TType::STRING, \TType::LST, count($_val66));
      if ($_val66 !== null)
      {
        foreach ($_val66 as $kiter67 => $viter68)
        {
          $xfer += $output->writeString($kiter67);
          $output->writeListBegin(\TType::I32, count($viter68));
          if ($viter68 !== null)
          {
            foreach ($viter68 as $iter69)
            {
              $xfer += $output->writeI32($iter69);
            }
          }
          $output->writeListEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_map_of_string_to_list_of_A !== null) {
      $_val70 = $this->optional_map_of_string_to_list_of_A;
      if (!($_val70 instanceof \Indexish) && !(($_val70 instanceof \Iterator || $_val70 instanceof \IteratorAggregate) && $_val70 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_map_of_string_to_list_of_A', \TType::MAP, 58);
      $output->writeMapBegin(\TType::STRING, \TType::LST, count($_val70));
      if ($_val70 !== null)
      {
        foreach ($_val70 as $kiter71 => $viter72)
        {
          $xfer += $output->writeString($kiter71);
          $output->writeListBegin(\TType::STRUCT, count($viter72));
          if ($viter72 !== null)
          {
            foreach ($viter72 as $iter73)
            {
              $xfer += $iter73->write($output);
            }
          }
          $output->writeListEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_map_of_string_to_set_of_i32 !== null) {
      $_val74 = $this->optional_map_of_string_to_set_of_i32;
      if (!($_val74 instanceof \Indexish) && !(($_val74 instanceof \Iterator || $_val74 instanceof \IteratorAggregate) && $_val74 instanceof \Countable)) {
        throw new \TProtocolException('Bad type in structure.', \TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('optional_map_of_string_to_set_of_i32', \TType::MAP, 59);
      $output->writeMapBegin(\TType::STRING, \TType::SET, count($_val74));
      if ($_val74 !== null)
      {
        foreach ($_val74 as $kiter75 => $viter76)
        {
          $xfer += $output->writeString($kiter75);
          $output->writeSetBegin(\TType::I32, count($viter76));
          if ($viter76 !== null)
          {
            foreach ($viter76 as $iter77)
            {
              $xfer += $output->writeI32($iter77);
            }
          }
          $output->writeSetEnd();
        }
      }
      $output->writeMapEnd();
      $xfer += $output->writeFieldEnd();
    }
    if ($this->optional_enum !== null) {
      $_val78 = \test\fixtures\Enum::assert($this->optional_enum);
      $xfer += $output->writeFieldBegin('optional_enum', \TType::I32, 60);
      $xfer += $output->writeI32($_val78);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


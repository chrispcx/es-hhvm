/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/module_types.h"

#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/module_types.tcc"


#include <algorithm>

namespace test_cpp2 { namespace cpp_reflection {

const typename apache::thrift::detail::TEnumMapFactory<enum1, enum1>::ValuesToNamesMapType _enum1_VALUES_TO_NAMES = apache::thrift::detail::TEnumMapFactory<enum1, enum1>::makeValuesToNamesMap();
const typename apache::thrift::detail::TEnumMapFactory<enum1, enum1>::NamesToValuesMapType _enum1_NAMES_TO_VALUES = apache::thrift::detail::TEnumMapFactory<enum1, enum1>::makeNamesToValuesMap();

}} // test_cpp2::cpp_reflection
namespace std {

} // std
namespace apache { namespace thrift {

template <> folly::Range<const std::pair< ::test_cpp2::cpp_reflection::enum1, folly::StringPiece>*> TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum1>::enumerators() {
  static constexpr const std::pair< ::test_cpp2::cpp_reflection::enum1, folly::StringPiece> storage[3] = {
    { ::test_cpp2::cpp_reflection::enum1::field0, "field0"},
    { ::test_cpp2::cpp_reflection::enum1::field1, "field1"},
    { ::test_cpp2::cpp_reflection::enum1::field2, "field2"},
  };
  return folly::range(storage);
}

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum1>::findName( ::test_cpp2::cpp_reflection::enum1 value) {
  return findName( ::test_cpp2::cpp_reflection::_enum1_VALUES_TO_NAMES, value);
}

template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum1>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum1* outValue) {
  return findValue( ::test_cpp2::cpp_reflection::_enum1_NAMES_TO_VALUES, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const typename apache::thrift::detail::TEnumMapFactory<enum2, enum2>::ValuesToNamesMapType _enum2_VALUES_TO_NAMES = apache::thrift::detail::TEnumMapFactory<enum2, enum2>::makeValuesToNamesMap();
const typename apache::thrift::detail::TEnumMapFactory<enum2, enum2>::NamesToValuesMapType _enum2_NAMES_TO_VALUES = apache::thrift::detail::TEnumMapFactory<enum2, enum2>::makeNamesToValuesMap();

}} // test_cpp2::cpp_reflection
namespace std {

} // std
namespace apache { namespace thrift {

template <> folly::Range<const std::pair< ::test_cpp2::cpp_reflection::enum2, folly::StringPiece>*> TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum2>::enumerators() {
  static constexpr const std::pair< ::test_cpp2::cpp_reflection::enum2, folly::StringPiece> storage[3] = {
    { ::test_cpp2::cpp_reflection::enum2::field0_2, "field0_2"},
    { ::test_cpp2::cpp_reflection::enum2::field1_2, "field1_2"},
    { ::test_cpp2::cpp_reflection::enum2::field2_2, "field2_2"},
  };
  return folly::range(storage);
}

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum2>::findName( ::test_cpp2::cpp_reflection::enum2 value) {
  return findName( ::test_cpp2::cpp_reflection::_enum2_VALUES_TO_NAMES, value);
}

template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum2>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum2* outValue) {
  return findValue( ::test_cpp2::cpp_reflection::_enum2_NAMES_TO_VALUES, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const typename apache::thrift::detail::TEnumMapFactory<enum3, enum3>::ValuesToNamesMapType _enum3_VALUES_TO_NAMES = apache::thrift::detail::TEnumMapFactory<enum3, enum3>::makeValuesToNamesMap();
const typename apache::thrift::detail::TEnumMapFactory<enum3, enum3>::NamesToValuesMapType _enum3_NAMES_TO_VALUES = apache::thrift::detail::TEnumMapFactory<enum3, enum3>::makeNamesToValuesMap();

}} // test_cpp2::cpp_reflection
namespace std {

} // std
namespace apache { namespace thrift {

template <> folly::Range<const std::pair< ::test_cpp2::cpp_reflection::enum3, folly::StringPiece>*> TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum3>::enumerators() {
  static constexpr const std::pair< ::test_cpp2::cpp_reflection::enum3, folly::StringPiece> storage[3] = {
    { ::test_cpp2::cpp_reflection::enum3::field0_3, "field0_3"},
    { ::test_cpp2::cpp_reflection::enum3::field1_3, "field1_3"},
    { ::test_cpp2::cpp_reflection::enum3::field2_3, "field2_3"},
  };
  return folly::range(storage);
}

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum3>::findName( ::test_cpp2::cpp_reflection::enum3 value) {
  return findName( ::test_cpp2::cpp_reflection::_enum3_VALUES_TO_NAMES, value);
}

template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum3>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum3* outValue) {
  return findValue( ::test_cpp2::cpp_reflection::_enum3_NAMES_TO_VALUES, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const typename apache::thrift::detail::TEnumMapFactory<enum_with_special_names, enum_with_special_names>::ValuesToNamesMapType _enum_with_special_names_VALUES_TO_NAMES = apache::thrift::detail::TEnumMapFactory<enum_with_special_names, enum_with_special_names>::makeValuesToNamesMap();
const typename apache::thrift::detail::TEnumMapFactory<enum_with_special_names, enum_with_special_names>::NamesToValuesMapType _enum_with_special_names_NAMES_TO_VALUES = apache::thrift::detail::TEnumMapFactory<enum_with_special_names, enum_with_special_names>::makeNamesToValuesMap();

}} // test_cpp2::cpp_reflection
namespace std {

} // std
namespace apache { namespace thrift {

template <> folly::Range<const std::pair< ::test_cpp2::cpp_reflection::enum_with_special_names, folly::StringPiece>*> TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum_with_special_names>::enumerators() {
  static constexpr const std::pair< ::test_cpp2::cpp_reflection::enum_with_special_names, folly::StringPiece> storage[26] = {
    { ::test_cpp2::cpp_reflection::enum_with_special_names::get, "get"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::getter, "getter"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::lists, "lists"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::maps, "maps"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::name, "name"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::name_to_value, "name_to_value"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::names, "names"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::prefix_tree, "prefix_tree"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::sets, "sets"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::setter, "setter"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::str, "str"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::strings, "strings"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::type, "type"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::value, "value"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::value_to_name, "value_to_name"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::values, "values"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::id, "id"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::ids, "ids"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::descriptor, "descriptor"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::descriptors, "descriptors"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::key, "key"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::keys, "keys"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::annotation, "annotation"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::annotations, "annotations"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::member, "member"},
    { ::test_cpp2::cpp_reflection::enum_with_special_names::members, "members"},
  };
  return folly::range(storage);
}

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum_with_special_names>::findName( ::test_cpp2::cpp_reflection::enum_with_special_names value) {
  return findName( ::test_cpp2::cpp_reflection::_enum_with_special_names_VALUES_TO_NAMES, value);
}

template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum_with_special_names>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum_with_special_names* outValue) {
  return findValue( ::test_cpp2::cpp_reflection::_enum_with_special_names_NAMES_TO_VALUES, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union1::__clear() {
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui:
    {
      destruct(value_.ui);
      break;
    }
    case Type::ud:
    {
      destruct(value_.ud);
      break;
    }
    case Type::us:
    {
      destruct(value_.us);
      break;
    }
    case Type::ue:
    {
      destruct(value_.ue);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union1::operator==(const union1& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui:
    {
      return value_.ui == rhs.value_.ui;
      break;
    }
    case Type::ud:
    {
      return value_.ud == rhs.value_.ud;
      break;
    }
    case Type::us:
    {
      return value_.us == rhs.value_.us;
      break;
    }
    case Type::ue:
    {
      return value_.ue == rhs.value_.ue;
      break;
    }
    default:
    {
      return true;
      break;
    }
  }
}

void swap(union1& a, union1& b) {
  union1 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template uint32_t union1::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union1::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union1::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union1::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union1::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t union1::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union1::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union1::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union2::__clear() {
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui_2:
    {
      destruct(value_.ui_2);
      break;
    }
    case Type::ud_2:
    {
      destruct(value_.ud_2);
      break;
    }
    case Type::us_2:
    {
      destruct(value_.us_2);
      break;
    }
    case Type::ue_2:
    {
      destruct(value_.ue_2);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union2::operator==(const union2& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui_2:
    {
      return value_.ui_2 == rhs.value_.ui_2;
      break;
    }
    case Type::ud_2:
    {
      return value_.ud_2 == rhs.value_.ud_2;
      break;
    }
    case Type::us_2:
    {
      return value_.us_2 == rhs.value_.us_2;
      break;
    }
    case Type::ue_2:
    {
      return value_.ue_2 == rhs.value_.ue_2;
      break;
    }
    default:
    {
      return true;
      break;
    }
  }
}

void swap(union2& a, union2& b) {
  union2 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template uint32_t union2::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union2::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t union2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union3::__clear() {
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui_3:
    {
      destruct(value_.ui_3);
      break;
    }
    case Type::ud_3:
    {
      destruct(value_.ud_3);
      break;
    }
    case Type::us_3:
    {
      destruct(value_.us_3);
      break;
    }
    case Type::ue_3:
    {
      destruct(value_.ue_3);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union3::operator==(const union3& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui_3:
    {
      return value_.ui_3 == rhs.value_.ui_3;
      break;
    }
    case Type::ud_3:
    {
      return value_.ud_3 == rhs.value_.ud_3;
      break;
    }
    case Type::us_3:
    {
      return value_.us_3 == rhs.value_.us_3;
      break;
    }
    case Type::ue_3:
    {
      return value_.ue_3 == rhs.value_.ue_3;
      break;
    }
    default:
    {
      return true;
      break;
    }
  }
}

void swap(union3& a, union3& b) {
  union3 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template uint32_t union3::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union3::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union3::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union3::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union3::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t union3::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union3::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union3::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void structA::__clear() {
  a = 0;
  b = std::string();
  __isset.__clear();
}

bool structA::operator==(const structA& rhs) const {
  if (!((a == rhs.a))) {
    return false;
  }
  if (!((b == rhs.b))) {
    return false;
  }
  return true;
}

void swap(structA& a, structA& b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.__isset, b.__isset);
}

template uint32_t structA::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structA::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structA::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structA::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structA::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t structA::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structA::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structA::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void unionA::__clear() {
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::i:
    {
      destruct(value_.i);
      break;
    }
    case Type::d:
    {
      destruct(value_.d);
      break;
    }
    case Type::s:
    {
      destruct(value_.s);
      break;
    }
    case Type::e:
    {
      destruct(value_.e);
      break;
    }
    case Type::a:
    {
      destruct(value_.a);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool unionA::operator==(const unionA& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::i:
    {
      return value_.i == rhs.value_.i;
      break;
    }
    case Type::d:
    {
      return value_.d == rhs.value_.d;
      break;
    }
    case Type::s:
    {
      return value_.s == rhs.value_.s;
      break;
    }
    case Type::e:
    {
      return value_.e == rhs.value_.e;
      break;
    }
    case Type::a:
    {
      return value_.a == rhs.value_.a;
      break;
    }
    default:
    {
      return true;
      break;
    }
  }
}

void swap(unionA& a, unionA& b) {
  unionA temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template uint32_t unionA::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t unionA::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t unionA::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t unionA::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t unionA::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t unionA::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t unionA::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t unionA::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void structB::__clear() {
  c = 0;
  d = 0;
  __isset.__clear();
}

bool structB::operator==(const structB& rhs) const {
  if (!((c == rhs.c))) {
    return false;
  }
  if (!((d == rhs.d))) {
    return false;
  }
  return true;
}

void swap(structB& a, structB& b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.__isset, b.__isset);
}

template uint32_t structB::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structB::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structB::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structB::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structB::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t structB::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structB::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structB::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void structC::__clear() {
  a = 0;
  b = std::string();
  c = 0;
  d = 0;
  e =  ::test_cpp2::cpp_reflection::enum1();
  f =  ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&g);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::unionA>::clear(&h);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::unionA>::clear(&i);
  j.clear();
  j1.clear();
  j2.clear();
  j3.clear();
  k.clear();
  k1.clear();
  k2.clear();
  k3.clear();
  l.clear();
  l1.clear();
  l2.clear();
  l3.clear();
  m1.clear();
  m2.clear();
  m3.clear();
  n1.clear();
  n2.clear();
  n3.clear();
  o1.clear();
  o2.clear();
  o3.clear();
  __isset.__clear();
}

bool structC::operator==(const structC& rhs) const {
  if (!((a == rhs.a))) {
    return false;
  }
  if (!((b == rhs.b))) {
    return false;
  }
  if (!((c == rhs.c))) {
    return false;
  }
  if (!((d == rhs.d))) {
    return false;
  }
  if (!((e == rhs.e))) {
    return false;
  }
  if (!((f == rhs.f))) {
    return false;
  }
  if (!((g == rhs.g))) {
    return false;
  }
  if (!((h == rhs.h))) {
    return false;
  }
  if (!((i == rhs.i))) {
    return false;
  }
  if (!((j == rhs.j))) {
    return false;
  }
  if (!((j1 == rhs.j1))) {
    return false;
  }
  if (!((j2 == rhs.j2))) {
    return false;
  }
  if (!((j3 == rhs.j3))) {
    return false;
  }
  if (!((k == rhs.k))) {
    return false;
  }
  if (!((k1 == rhs.k1))) {
    return false;
  }
  if (!((k2 == rhs.k2))) {
    return false;
  }
  if (!((k3 == rhs.k3))) {
    return false;
  }
  if (!((l == rhs.l))) {
    return false;
  }
  if (!((l1 == rhs.l1))) {
    return false;
  }
  if (!((l2 == rhs.l2))) {
    return false;
  }
  if (!((l3 == rhs.l3))) {
    return false;
  }
  if (!((m1 == rhs.m1))) {
    return false;
  }
  if (!((m2 == rhs.m2))) {
    return false;
  }
  if (!((m3 == rhs.m3))) {
    return false;
  }
  if (!((n1 == rhs.n1))) {
    return false;
  }
  if (!((n2 == rhs.n2))) {
    return false;
  }
  if (!((n3 == rhs.n3))) {
    return false;
  }
  if (!((o1 == rhs.o1))) {
    return false;
  }
  if (!((o2 == rhs.o2))) {
    return false;
  }
  if (!((o3 == rhs.o3))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::union1& structC::get_g() const& {
  return g;
}

 ::test_cpp2::cpp_reflection::union1 structC::get_g() && {
  return std::move(g);
}

const  ::test_cpp2::cpp_reflection::unionA& structC::get_h() const& {
  return h;
}

 ::test_cpp2::cpp_reflection::unionA structC::get_h() && {
  return std::move(h);
}

const  ::test_cpp2::cpp_reflection::unionA& structC::get_i() const& {
  return i;
}

 ::test_cpp2::cpp_reflection::unionA structC::get_i() && {
  return std::move(i);
}

const std::vector<int32_t>& structC::get_j() const& {
  return j;
}

std::vector<int32_t> structC::get_j() && {
  return std::move(j);
}

const std::vector<int32_t>& structC::get_j1() const& {
  return j1;
}

std::vector<int32_t> structC::get_j1() && {
  return std::move(j1);
}

const std::vector< ::test_cpp2::cpp_reflection::enum1>& structC::get_j2() const& {
  return j2;
}

std::vector< ::test_cpp2::cpp_reflection::enum1> structC::get_j2() && {
  return std::move(j2);
}

const std::vector< ::test_cpp2::cpp_reflection::structA>& structC::get_j3() const& {
  return j3;
}

std::vector< ::test_cpp2::cpp_reflection::structA> structC::get_j3() && {
  return std::move(j3);
}

const std::set<int32_t>& structC::get_k() const& {
  return k;
}

std::set<int32_t> structC::get_k() && {
  return std::move(k);
}

const std::set<int32_t>& structC::get_k1() const& {
  return k1;
}

std::set<int32_t> structC::get_k1() && {
  return std::move(k1);
}

const std::set< ::test_cpp2::cpp_reflection::enum2>& structC::get_k2() const& {
  return k2;
}

std::set< ::test_cpp2::cpp_reflection::enum2> structC::get_k2() && {
  return std::move(k2);
}

const std::set< ::test_cpp2::cpp_reflection::structB>& structC::get_k3() const& {
  return k3;
}

std::set< ::test_cpp2::cpp_reflection::structB> structC::get_k3() && {
  return std::move(k3);
}

const std::map<int32_t, int32_t>& structC::get_l() const& {
  return l;
}

std::map<int32_t, int32_t> structC::get_l() && {
  return std::move(l);
}

const std::map<int32_t, int32_t>& structC::get_l1() const& {
  return l1;
}

std::map<int32_t, int32_t> structC::get_l1() && {
  return std::move(l1);
}

const std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1>& structC::get_l2() const& {
  return l2;
}

std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1> structC::get_l2() && {
  return std::move(l2);
}

const std::map<int32_t,  ::test_cpp2::cpp_reflection::structB>& structC::get_l3() const& {
  return l3;
}

std::map<int32_t,  ::test_cpp2::cpp_reflection::structB> structC::get_l3() && {
  return std::move(l3);
}

const std::map< ::test_cpp2::cpp_reflection::enum1, int32_t>& structC::get_m1() const& {
  return m1;
}

std::map< ::test_cpp2::cpp_reflection::enum1, int32_t> structC::get_m1() && {
  return std::move(m1);
}

const std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2>& structC::get_m2() const& {
  return m2;
}

std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2> structC::get_m2() && {
  return std::move(m2);
}

const std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB>& structC::get_m3() const& {
  return m3;
}

std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB> structC::get_m3() && {
  return std::move(m3);
}

const std::map<std::string, int32_t>& structC::get_n1() const& {
  return n1;
}

std::map<std::string, int32_t> structC::get_n1() && {
  return std::move(n1);
}

const std::map<std::string,  ::test_cpp2::cpp_reflection::enum1>& structC::get_n2() const& {
  return n2;
}

std::map<std::string,  ::test_cpp2::cpp_reflection::enum1> structC::get_n2() && {
  return std::move(n2);
}

const std::map<std::string,  ::test_cpp2::cpp_reflection::structB>& structC::get_n3() const& {
  return n3;
}

std::map<std::string,  ::test_cpp2::cpp_reflection::structB> structC::get_n3() && {
  return std::move(n3);
}

const std::map< ::test_cpp2::cpp_reflection::structA, int32_t>& structC::get_o1() const& {
  return o1;
}

std::map< ::test_cpp2::cpp_reflection::structA, int32_t> structC::get_o1() && {
  return std::move(o1);
}

const std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1>& structC::get_o2() const& {
  return o2;
}

std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1> structC::get_o2() && {
  return std::move(o2);
}

const std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB>& structC::get_o3() const& {
  return o3;
}

std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB> structC::get_o3() && {
  return std::move(o3);
}

void swap(structC& a, structC& b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.e, b.e);
  swap(a.f, b.f);
  swap(a.g, b.g);
  swap(a.h, b.h);
  swap(a.i, b.i);
  swap(a.j, b.j);
  swap(a.j1, b.j1);
  swap(a.j2, b.j2);
  swap(a.j3, b.j3);
  swap(a.k, b.k);
  swap(a.k1, b.k1);
  swap(a.k2, b.k2);
  swap(a.k3, b.k3);
  swap(a.l, b.l);
  swap(a.l1, b.l1);
  swap(a.l2, b.l2);
  swap(a.l3, b.l3);
  swap(a.m1, b.m1);
  swap(a.m2, b.m2);
  swap(a.m3, b.m3);
  swap(a.n1, b.n1);
  swap(a.n2, b.n2);
  swap(a.n3, b.n3);
  swap(a.o1, b.o1);
  swap(a.o2, b.o2);
  swap(a.o3, b.o3);
  swap(a.__isset, b.__isset);
}

template uint32_t structC::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structC::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structC::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structC::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structC::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t structC::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structC::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structC::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void struct1::__clear() {
  field0 = 0;
  field1 = std::string();
  field2 =  ::test_cpp2::cpp_reflection::enum1();
  field3 =  ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&field4);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&field5);
  __isset.__clear();
}

bool struct1::operator==(const struct1& rhs) const {
  if (!((field0 == rhs.field0))) {
    return false;
  }
  if (__isset.field1 != rhs.__isset.field1) {
    return false;
  }
  else if (__isset.field1 && !((field1 == rhs.field1))) {
    return false;
  }
  if (!((field2 == rhs.field2))) {
    return false;
  }
  if (!((field3 == rhs.field3))) {
    return false;
  }
  if (__isset.field4 != rhs.__isset.field4) {
    return false;
  }
  else if (__isset.field4 && !((field4 == rhs.field4))) {
    return false;
  }
  if (!((field5 == rhs.field5))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::union1* struct1::get_field4() const& {
  return __isset.field4 ? std::addressof(field4) : nullptr;
}

 ::test_cpp2::cpp_reflection::union1* struct1::get_field4() & {
  return __isset.field4 ? std::addressof(field4) : nullptr;
}

const  ::test_cpp2::cpp_reflection::union2& struct1::get_field5() const& {
  return field5;
}

 ::test_cpp2::cpp_reflection::union2 struct1::get_field5() && {
  return std::move(field5);
}

void swap(struct1& a, struct1& b) {
  using ::std::swap;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.field4, b.field4);
  swap(a.field5, b.field5);
  swap(a.__isset, b.__isset);
}

template uint32_t struct1::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct1::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct1::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct1::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct1::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct1::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct1::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct1::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void struct2::__clear() {
  fieldA = 0;
  fieldB = std::string();
  fieldC =  ::test_cpp2::cpp_reflection::enum1();
  fieldD =  ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&fieldE);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldF);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::struct1>::clear(&fieldG);
  __isset.__clear();
}

bool struct2::operator==(const struct2& rhs) const {
  if (!((fieldA == rhs.fieldA))) {
    return false;
  }
  if (!((fieldB == rhs.fieldB))) {
    return false;
  }
  if (!((fieldC == rhs.fieldC))) {
    return false;
  }
  if (!((fieldD == rhs.fieldD))) {
    return false;
  }
  if (!((fieldE == rhs.fieldE))) {
    return false;
  }
  if (!((fieldF == rhs.fieldF))) {
    return false;
  }
  if (!((fieldG == rhs.fieldG))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::union1& struct2::get_fieldE() const& {
  return fieldE;
}

 ::test_cpp2::cpp_reflection::union1 struct2::get_fieldE() && {
  return std::move(fieldE);
}

const  ::test_cpp2::cpp_reflection::union2& struct2::get_fieldF() const& {
  return fieldF;
}

 ::test_cpp2::cpp_reflection::union2 struct2::get_fieldF() && {
  return std::move(fieldF);
}

const  ::test_cpp2::cpp_reflection::struct1& struct2::get_fieldG() const& {
  return fieldG;
}

 ::test_cpp2::cpp_reflection::struct1 struct2::get_fieldG() && {
  return std::move(fieldG);
}

void swap(struct2& a, struct2& b) {
  using ::std::swap;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.__isset, b.__isset);
}

template uint32_t struct2::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct2::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void struct3::__clear() {
  fieldA = 0;
  fieldB = std::string();
  fieldC =  ::test_cpp2::cpp_reflection::enum1();
  fieldD =  ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&fieldE);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldF);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::struct1>::clear(&fieldG);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldH);
  fieldI.clear();
  fieldJ.clear();
  fieldK.clear();
  fieldL.clear();
  fieldM.clear();
  fieldN.clear();
  fieldO.clear();
  fieldP.clear();
  fieldQ.clear();
  fieldR.clear();
  __isset.__clear();
}

bool struct3::operator==(const struct3& rhs) const {
  if (!((fieldA == rhs.fieldA))) {
    return false;
  }
  if (!((fieldB == rhs.fieldB))) {
    return false;
  }
  if (!((fieldC == rhs.fieldC))) {
    return false;
  }
  if (!((fieldD == rhs.fieldD))) {
    return false;
  }
  if (!((fieldE == rhs.fieldE))) {
    return false;
  }
  if (!((fieldF == rhs.fieldF))) {
    return false;
  }
  if (!((fieldG == rhs.fieldG))) {
    return false;
  }
  if (!((fieldH == rhs.fieldH))) {
    return false;
  }
  if (!((fieldI == rhs.fieldI))) {
    return false;
  }
  if (!((fieldJ == rhs.fieldJ))) {
    return false;
  }
  if (!((fieldK == rhs.fieldK))) {
    return false;
  }
  if (!((fieldL == rhs.fieldL))) {
    return false;
  }
  if (!((fieldM == rhs.fieldM))) {
    return false;
  }
  if (!((fieldN == rhs.fieldN))) {
    return false;
  }
  if (!((fieldO == rhs.fieldO))) {
    return false;
  }
  if (!((fieldP == rhs.fieldP))) {
    return false;
  }
  if (!((fieldQ == rhs.fieldQ))) {
    return false;
  }
  if (!((fieldR == rhs.fieldR))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::union1& struct3::get_fieldE() const& {
  return fieldE;
}

 ::test_cpp2::cpp_reflection::union1 struct3::get_fieldE() && {
  return std::move(fieldE);
}

const  ::test_cpp2::cpp_reflection::union2& struct3::get_fieldF() const& {
  return fieldF;
}

 ::test_cpp2::cpp_reflection::union2 struct3::get_fieldF() && {
  return std::move(fieldF);
}

const  ::test_cpp2::cpp_reflection::struct1& struct3::get_fieldG() const& {
  return fieldG;
}

 ::test_cpp2::cpp_reflection::struct1 struct3::get_fieldG() && {
  return std::move(fieldG);
}

const  ::test_cpp2::cpp_reflection::union2& struct3::get_fieldH() const& {
  return fieldH;
}

 ::test_cpp2::cpp_reflection::union2 struct3::get_fieldH() && {
  return std::move(fieldH);
}

const std::vector<int32_t>& struct3::get_fieldI() const& {
  return fieldI;
}

std::vector<int32_t> struct3::get_fieldI() && {
  return std::move(fieldI);
}

const std::vector<std::string>& struct3::get_fieldJ() const& {
  return fieldJ;
}

std::vector<std::string> struct3::get_fieldJ() && {
  return std::move(fieldJ);
}

const std::vector<std::string>& struct3::get_fieldK() const& {
  return fieldK;
}

std::vector<std::string> struct3::get_fieldK() && {
  return std::move(fieldK);
}

const std::vector< ::test_cpp2::cpp_reflection::structA>& struct3::get_fieldL() const& {
  return fieldL;
}

std::vector< ::test_cpp2::cpp_reflection::structA> struct3::get_fieldL() && {
  return std::move(fieldL);
}

const std::set<int32_t>& struct3::get_fieldM() const& {
  return fieldM;
}

std::set<int32_t> struct3::get_fieldM() && {
  return std::move(fieldM);
}

const std::set<std::string>& struct3::get_fieldN() const& {
  return fieldN;
}

std::set<std::string> struct3::get_fieldN() && {
  return std::move(fieldN);
}

const std::set<std::string>& struct3::get_fieldO() const& {
  return fieldO;
}

std::set<std::string> struct3::get_fieldO() && {
  return std::move(fieldO);
}

const std::set< ::test_cpp2::cpp_reflection::structB>& struct3::get_fieldP() const& {
  return fieldP;
}

std::set< ::test_cpp2::cpp_reflection::structB> struct3::get_fieldP() && {
  return std::move(fieldP);
}

const std::map<std::string,  ::test_cpp2::cpp_reflection::structA>& struct3::get_fieldQ() const& {
  return fieldQ;
}

std::map<std::string,  ::test_cpp2::cpp_reflection::structA> struct3::get_fieldQ() && {
  return std::move(fieldQ);
}

const std::map<std::string,  ::test_cpp2::cpp_reflection::structB>& struct3::get_fieldR() const& {
  return fieldR;
}

std::map<std::string,  ::test_cpp2::cpp_reflection::structB> struct3::get_fieldR() && {
  return std::move(fieldR);
}

void swap(struct3& a, struct3& b) {
  using ::std::swap;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.fieldH, b.fieldH);
  swap(a.fieldI, b.fieldI);
  swap(a.fieldJ, b.fieldJ);
  swap(a.fieldK, b.fieldK);
  swap(a.fieldL, b.fieldL);
  swap(a.fieldM, b.fieldM);
  swap(a.fieldN, b.fieldN);
  swap(a.fieldO, b.fieldO);
  swap(a.fieldP, b.fieldP);
  swap(a.fieldQ, b.fieldQ);
  swap(a.fieldR, b.fieldR);
  swap(a.__isset, b.__isset);
}

template uint32_t struct3::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct3::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct3::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct3::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct3::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct3::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct3::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct3::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

struct4::struct4(const struct4& src) {
  field0 = src.field0;
  field1 = src.field1;
  __isset.field1 = src.__isset.field1;
  field2 = src.field2;
  __isset.field2 = src.__isset.field2;
  if (src.field3) field3.reset(new  ::test_cpp2::cpp_reflection::structA(*src.field3));
}

struct4& struct4::operator=(const struct4& src) {
  struct4 tmp(src);
  swap(*this, tmp);
  return *this;
}

void struct4::__clear() {
  field0 = 0;
  field1 = std::string();
  field2 =  ::test_cpp2::cpp_reflection::enum1();
  if (field3) ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::structA>::clear(field3.get());
  __isset.__clear();
}

bool struct4::operator==(const struct4& rhs) const {
  if (!((field0 == rhs.field0))) {
    return false;
  }
  if (__isset.field1 != rhs.__isset.field1) {
    return false;
  }
  else if (__isset.field1 && !((field1 == rhs.field1))) {
    return false;
  }
  if (!((field2 == rhs.field2))) {
    return false;
  }
  if (!(((field3 && rhs.field3 && *field3 == *rhs.field3) ||(!field3 && !rhs.field3)))) {
    return false;
  }
  return true;
}

void swap(struct4& a, struct4& b) {
  using ::std::swap;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.__isset, b.__isset);
}

template uint32_t struct4::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct4::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct4::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct4::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct4::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct4::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct4::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct4::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void struct5::__clear() {
  field0 = 0;
  field1 = std::string();
  field2 =  ::test_cpp2::cpp_reflection::enum1();
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::structA>::clear(&field3);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::structB>::clear(&field4);
  __isset.__clear();
}

bool struct5::operator==(const struct5& rhs) const {
  if (!((field0 == rhs.field0))) {
    return false;
  }
  if (__isset.field1 != rhs.__isset.field1) {
    return false;
  }
  else if (__isset.field1 && !((field1 == rhs.field1))) {
    return false;
  }
  if (!((field2 == rhs.field2))) {
    return false;
  }
  if (!((field3 == rhs.field3))) {
    return false;
  }
  if (!((field4 == rhs.field4))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::structA& struct5::get_field3() const& {
  return field3;
}

 ::test_cpp2::cpp_reflection::structA struct5::get_field3() && {
  return std::move(field3);
}

const  ::test_cpp2::cpp_reflection::structB& struct5::get_field4() const& {
  return field4;
}

 ::test_cpp2::cpp_reflection::structB struct5::get_field4() && {
  return std::move(field4);
}

void swap(struct5& a, struct5& b) {
  using ::std::swap;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.field4, b.field4);
  swap(a.__isset, b.__isset);
}

template uint32_t struct5::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct5::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct5::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct5::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct5::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct5::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct5::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct5::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void struct_binary::__clear() {
  bi = std::string();
  __isset.__clear();
}

bool struct_binary::operator==(const struct_binary& rhs) const {
  if (!(apache::thrift::StringTraits<std::string>::isEqual(bi, rhs.bi))) {
    return false;
  }
  return true;
}

void swap(struct_binary& a, struct_binary& b) {
  using ::std::swap;
  swap(a.bi, b.bi);
  swap(a.__isset, b.__isset);
}

template uint32_t struct_binary::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_binary::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_binary::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_binary::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_binary::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_binary::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_binary::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_binary::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void annotated::__clear() {
  a = 0;
  __isset.__clear();
}

bool annotated::operator==(const annotated& rhs) const {
  if (!((a == rhs.a))) {
    return false;
  }
  return true;
}

void swap(annotated& a, annotated& b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.__isset, b.__isset);
}

template uint32_t annotated::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t annotated::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t annotated::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t annotated::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t annotated::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t annotated::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t annotated::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t annotated::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union_with_special_names::__clear() {
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::get:
    {
      destruct(value_.get);
      break;
    }
    case Type::getter:
    {
      destruct(value_.getter);
      break;
    }
    case Type::lists:
    {
      destruct(value_.lists);
      break;
    }
    case Type::maps:
    {
      destruct(value_.maps);
      break;
    }
    case Type::name:
    {
      destruct(value_.name);
      break;
    }
    case Type::name_to_value:
    {
      destruct(value_.name_to_value);
      break;
    }
    case Type::names:
    {
      destruct(value_.names);
      break;
    }
    case Type::prefix_tree:
    {
      destruct(value_.prefix_tree);
      break;
    }
    case Type::sets:
    {
      destruct(value_.sets);
      break;
    }
    case Type::setter:
    {
      destruct(value_.setter);
      break;
    }
    case Type::str:
    {
      destruct(value_.str);
      break;
    }
    case Type::strings:
    {
      destruct(value_.strings);
      break;
    }
    case Type::type:
    {
      destruct(value_.type);
      break;
    }
    case Type::value:
    {
      destruct(value_.value);
      break;
    }
    case Type::value_to_name:
    {
      destruct(value_.value_to_name);
      break;
    }
    case Type::values:
    {
      destruct(value_.values);
      break;
    }
    case Type::id:
    {
      destruct(value_.id);
      break;
    }
    case Type::ids:
    {
      destruct(value_.ids);
      break;
    }
    case Type::descriptor:
    {
      destruct(value_.descriptor);
      break;
    }
    case Type::descriptors:
    {
      destruct(value_.descriptors);
      break;
    }
    case Type::key:
    {
      destruct(value_.key);
      break;
    }
    case Type::keys:
    {
      destruct(value_.keys);
      break;
    }
    case Type::annotation:
    {
      destruct(value_.annotation);
      break;
    }
    case Type::annotations:
    {
      destruct(value_.annotations);
      break;
    }
    case Type::member:
    {
      destruct(value_.member);
      break;
    }
    case Type::members:
    {
      destruct(value_.members);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union_with_special_names::operator==(const union_with_special_names& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::get:
    {
      return value_.get == rhs.value_.get;
      break;
    }
    case Type::getter:
    {
      return value_.getter == rhs.value_.getter;
      break;
    }
    case Type::lists:
    {
      return value_.lists == rhs.value_.lists;
      break;
    }
    case Type::maps:
    {
      return value_.maps == rhs.value_.maps;
      break;
    }
    case Type::name:
    {
      return value_.name == rhs.value_.name;
      break;
    }
    case Type::name_to_value:
    {
      return value_.name_to_value == rhs.value_.name_to_value;
      break;
    }
    case Type::names:
    {
      return value_.names == rhs.value_.names;
      break;
    }
    case Type::prefix_tree:
    {
      return value_.prefix_tree == rhs.value_.prefix_tree;
      break;
    }
    case Type::sets:
    {
      return value_.sets == rhs.value_.sets;
      break;
    }
    case Type::setter:
    {
      return value_.setter == rhs.value_.setter;
      break;
    }
    case Type::str:
    {
      return value_.str == rhs.value_.str;
      break;
    }
    case Type::strings:
    {
      return value_.strings == rhs.value_.strings;
      break;
    }
    case Type::type:
    {
      return value_.type == rhs.value_.type;
      break;
    }
    case Type::value:
    {
      return value_.value == rhs.value_.value;
      break;
    }
    case Type::value_to_name:
    {
      return value_.value_to_name == rhs.value_.value_to_name;
      break;
    }
    case Type::values:
    {
      return value_.values == rhs.value_.values;
      break;
    }
    case Type::id:
    {
      return value_.id == rhs.value_.id;
      break;
    }
    case Type::ids:
    {
      return value_.ids == rhs.value_.ids;
      break;
    }
    case Type::descriptor:
    {
      return value_.descriptor == rhs.value_.descriptor;
      break;
    }
    case Type::descriptors:
    {
      return value_.descriptors == rhs.value_.descriptors;
      break;
    }
    case Type::key:
    {
      return value_.key == rhs.value_.key;
      break;
    }
    case Type::keys:
    {
      return value_.keys == rhs.value_.keys;
      break;
    }
    case Type::annotation:
    {
      return value_.annotation == rhs.value_.annotation;
      break;
    }
    case Type::annotations:
    {
      return value_.annotations == rhs.value_.annotations;
      break;
    }
    case Type::member:
    {
      return value_.member == rhs.value_.member;
      break;
    }
    case Type::members:
    {
      return value_.members == rhs.value_.members;
      break;
    }
    default:
    {
      return true;
      break;
    }
  }
}

void swap(union_with_special_names& a, union_with_special_names& b) {
  union_with_special_names temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template uint32_t union_with_special_names::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union_with_special_names::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union_with_special_names::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union_with_special_names::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union_with_special_names::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t union_with_special_names::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union_with_special_names::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union_with_special_names::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void struct_with_special_names::__clear() {
  get = 0;
  getter = 0;
  lists = 0;
  maps = 0;
  name = 0;
  name_to_value = 0;
  names = 0;
  prefix_tree = 0;
  sets = 0;
  setter = 0;
  str = 0;
  strings = 0;
  type = 0;
  value = 0;
  value_to_name = 0;
  values = 0;
  id = 0;
  ids = 0;
  descriptor = 0;
  descriptors = 0;
  key = 0;
  keys = 0;
  annotation = 0;
  annotations = 0;
  member = 0;
  members = 0;
  __isset.__clear();
}

bool struct_with_special_names::operator==(const struct_with_special_names& rhs) const {
  if (!((get == rhs.get))) {
    return false;
  }
  if (!((getter == rhs.getter))) {
    return false;
  }
  if (!((lists == rhs.lists))) {
    return false;
  }
  if (!((maps == rhs.maps))) {
    return false;
  }
  if (!((name == rhs.name))) {
    return false;
  }
  if (!((name_to_value == rhs.name_to_value))) {
    return false;
  }
  if (!((names == rhs.names))) {
    return false;
  }
  if (!((prefix_tree == rhs.prefix_tree))) {
    return false;
  }
  if (!((sets == rhs.sets))) {
    return false;
  }
  if (!((setter == rhs.setter))) {
    return false;
  }
  if (!((str == rhs.str))) {
    return false;
  }
  if (!((strings == rhs.strings))) {
    return false;
  }
  if (!((type == rhs.type))) {
    return false;
  }
  if (!((value == rhs.value))) {
    return false;
  }
  if (!((value_to_name == rhs.value_to_name))) {
    return false;
  }
  if (!((values == rhs.values))) {
    return false;
  }
  if (!((id == rhs.id))) {
    return false;
  }
  if (!((ids == rhs.ids))) {
    return false;
  }
  if (!((descriptor == rhs.descriptor))) {
    return false;
  }
  if (!((descriptors == rhs.descriptors))) {
    return false;
  }
  if (!((key == rhs.key))) {
    return false;
  }
  if (!((keys == rhs.keys))) {
    return false;
  }
  if (!((annotation == rhs.annotation))) {
    return false;
  }
  if (!((annotations == rhs.annotations))) {
    return false;
  }
  if (!((member == rhs.member))) {
    return false;
  }
  if (!((members == rhs.members))) {
    return false;
  }
  return true;
}

void swap(struct_with_special_names& a, struct_with_special_names& b) {
  using ::std::swap;
  swap(a.get, b.get);
  swap(a.getter, b.getter);
  swap(a.lists, b.lists);
  swap(a.maps, b.maps);
  swap(a.name, b.name);
  swap(a.name_to_value, b.name_to_value);
  swap(a.names, b.names);
  swap(a.prefix_tree, b.prefix_tree);
  swap(a.sets, b.sets);
  swap(a.setter, b.setter);
  swap(a.str, b.str);
  swap(a.strings, b.strings);
  swap(a.type, b.type);
  swap(a.value, b.value);
  swap(a.value_to_name, b.value_to_name);
  swap(a.values, b.values);
  swap(a.id, b.id);
  swap(a.ids, b.ids);
  swap(a.descriptor, b.descriptor);
  swap(a.descriptors, b.descriptors);
  swap(a.key, b.key);
  swap(a.keys, b.keys);
  swap(a.annotation, b.annotation);
  swap(a.annotations, b.annotations);
  swap(a.member, b.member);
  swap(a.members, b.members);
  swap(a.__isset, b.__isset);
}

template uint32_t struct_with_special_names::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_with_special_names::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_with_special_names::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_with_special_names::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_with_special_names::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_with_special_names::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_with_special_names::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_with_special_names::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

}} // test_cpp2::cpp_reflection

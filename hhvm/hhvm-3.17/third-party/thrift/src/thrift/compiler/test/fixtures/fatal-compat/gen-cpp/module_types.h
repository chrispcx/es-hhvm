/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp/Thrift.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <thrift/lib/cpp/protocol/TProtocol.h>
#include <thrift/lib/cpp/transport/TTransport.h>

#include <folly/json.h>

#include <folly/Range.h>

#include <folly/Conv.h>

#include <math.h>

#include <thrift/lib/cpp/Thrift.h>

using namespace folly::json;
namespace apache { namespace thrift { namespace reflection {
class Schema;
}}}

#include "thrift/test/fatal_custom_types.h"

namespace test_cpp1 { namespace cpp_reflection {

enum enum1 {
  field0 = 0,
  field1 = 1,
  field2 = 2,
};

extern const typename apache::thrift::detail::TEnumMapFactory<enum1, int>::ValuesToNamesMapType _enum1_VALUES_TO_NAMES;

extern const typename apache::thrift::detail::TEnumMapFactory<enum1, int>::NamesToValuesMapType _enum1_NAMES_TO_VALUES;

}} // namespace
namespace apache { namespace thrift {
template<>
struct TEnumTraits< ::test_cpp1::cpp_reflection::enum1> : public TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum1>
{
inline static constexpr  ::test_cpp1::cpp_reflection::enum1 min() {
return  ::test_cpp1::cpp_reflection::enum1::field0;
}
inline static constexpr  ::test_cpp1::cpp_reflection::enum1 max() {
return  ::test_cpp1::cpp_reflection::enum1::field2;
}
};
}} // apache:thrift

namespace test_cpp1 { namespace cpp_reflection {
enum enum2 {
  field0_2 = 0,
  field1_2 = 1,
  field2_2 = 2,
};

extern const typename apache::thrift::detail::TEnumMapFactory<enum2, int>::ValuesToNamesMapType _enum2_VALUES_TO_NAMES;

extern const typename apache::thrift::detail::TEnumMapFactory<enum2, int>::NamesToValuesMapType _enum2_NAMES_TO_VALUES;

}} // namespace
namespace apache { namespace thrift {
template<>
struct TEnumTraits< ::test_cpp1::cpp_reflection::enum2> : public TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum2>
{
inline static constexpr  ::test_cpp1::cpp_reflection::enum2 min() {
return  ::test_cpp1::cpp_reflection::enum2::field0_2;
}
inline static constexpr  ::test_cpp1::cpp_reflection::enum2 max() {
return  ::test_cpp1::cpp_reflection::enum2::field2_2;
}
};
}} // apache:thrift

namespace test_cpp1 { namespace cpp_reflection {
enum enum3 {
  field0_3 = 0,
  field1_3 = 1,
  field2_3 = 2,
};

extern const typename apache::thrift::detail::TEnumMapFactory<enum3, int>::ValuesToNamesMapType _enum3_VALUES_TO_NAMES;

extern const typename apache::thrift::detail::TEnumMapFactory<enum3, int>::NamesToValuesMapType _enum3_NAMES_TO_VALUES;

}} // namespace
namespace apache { namespace thrift {
template<>
struct TEnumTraits< ::test_cpp1::cpp_reflection::enum3> : public TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum3>
{
inline static constexpr  ::test_cpp1::cpp_reflection::enum3 min() {
return  ::test_cpp1::cpp_reflection::enum3::field0_3;
}
inline static constexpr  ::test_cpp1::cpp_reflection::enum3 max() {
return  ::test_cpp1::cpp_reflection::enum3::field2_3;
}
};
}} // apache:thrift

namespace test_cpp1 { namespace cpp_reflection {
enum enum_with_special_names {
  get = 0,
  getter = 1,
  lists = 2,
  maps = 3,
  name = 4,
  name_to_value = 5,
  names = 6,
  prefix_tree = 7,
  sets = 8,
  setter = 9,
  str = 10,
  strings = 11,
  type = 12,
  value = 13,
  value_to_name = 14,
  values = 15,
  id = 16,
  ids = 17,
  descriptor = 18,
  descriptors = 19,
  key = 20,
  keys = 21,
  annotation = 22,
  annotations = 23,
  member = 24,
  members = 25,
};

extern const typename apache::thrift::detail::TEnumMapFactory<enum_with_special_names, int>::ValuesToNamesMapType _enum_with_special_names_VALUES_TO_NAMES;

extern const typename apache::thrift::detail::TEnumMapFactory<enum_with_special_names, int>::NamesToValuesMapType _enum_with_special_names_NAMES_TO_VALUES;

}} // namespace
namespace apache { namespace thrift {
template<>
struct TEnumTraits< ::test_cpp1::cpp_reflection::enum_with_special_names> : public TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum_with_special_names>
{
inline static constexpr  ::test_cpp1::cpp_reflection::enum_with_special_names min() {
return  ::test_cpp1::cpp_reflection::enum_with_special_names::get;
}
inline static constexpr  ::test_cpp1::cpp_reflection::enum_with_special_names max() {
return  ::test_cpp1::cpp_reflection::enum_with_special_names::members;
}
};
}} // apache:thrift

namespace test_cpp1 { namespace cpp_reflection {
class union1;

class union2;

class union3;

class structA;

class unionA;

class structB;

class structC;

class struct1;

class struct2;

class struct3;

class struct4;

class struct5;

class struct_binary;

class annotated;

class union_with_special_names;

class struct_with_special_names;

typedef test_cpp_reflection::custom_structA my_structA;

class union1 : public apache::thrift::TStructType<union1> {
 public:
  enum class Type {
    __EMPTY__ = 0,
    ui = 1,
    ud = 2,
    us = 3,
    ue = 4,
  };

  union1() : type_(Type::__EMPTY__) {}
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union1(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_ui(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union1(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_ud(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union1(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_us(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union1(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_ue(arg.move());
  }
  union1(const union1& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui: {
        set_ui(rhs.value_.ui);
        break;
      }
      case Type::ud: {
        set_ud(rhs.value_.ud);
        break;
      }
      case Type::us: {
        set_us(rhs.value_.us);
        break;
      }
      case Type::ue: {
        set_ue(rhs.value_.ue);
        break;
      }
      default: assert(false);
    }
  }

  union1& operator=(const union1& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui: {
        set_ui(rhs.value_.ui);
        break;
      }
      case Type::ud: {
        set_ud(rhs.value_.ud);
        break;
      }
      case Type::us: {
        set_us(rhs.value_.us);
        break;
      }
      case Type::ue: {
        set_ue(rhs.value_.ue);
        break;
      }
      default: assert(false);
    }
    return *this;
  }

  union1(union1&& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui: {
        set_ui(std::move(rhs.value_.ui));
        break;
      }
      case Type::ud: {
        set_ud(std::move(rhs.value_.ud));
        break;
      }
      case Type::us: {
        set_us(std::move(rhs.value_.us));
        break;
      }
      case Type::ue: {
        set_ue(std::move(rhs.value_.ue));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
  }

  union1& operator=(union1&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui: {
        set_ui(std::move(rhs.value_.ui));
        break;
      }
      case Type::ud: {
        set_ud(std::move(rhs.value_.ud));
        break;
      }
      case Type::us: {
        set_us(std::move(rhs.value_.us));
        break;
      }
      case Type::ue: {
        set_ue(std::move(rhs.value_.ue));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
    return *this;
  }


  void __clear() {
    if (type_ == Type::__EMPTY__) { return; }
    switch (type_) {
      case Type::ui: {
        
        break;
      }
      case Type::ud: {
        
        break;
      }
      case Type::us: {
        using namespace std; value_.us.~string();
        break;
      }
      case Type::ue: {
        value_.ue.~enum1();
        break;
      }
      default: assert(false);
    }
    type_ = Type::__EMPTY__;
  }
  virtual ~union1() throw() {
    __clear();
  }

  union storage_type {
    int32_t ui;
    double ud;
    std::string us;
    enum1 ue;
    
    storage_type() {}
    ~storage_type() {}
  };

  bool operator==(const union1& rhs) const {
    if (type_ != rhs.type_) { return false; }
    switch (type_) {
      case Type::ui: {
        return value_.ui == rhs.value_.ui;

        break;
      }
      case Type::ud: {
        return value_.ud == rhs.value_.ud;

        break;
      }
      case Type::us: {
        return value_.us == rhs.value_.us;

        break;
      }
      case Type::ue: {
        return value_.ue == rhs.value_.ue;

        break;
      }
      default: return true;
    }
  }

  bool operator!=(const union1& rhs) const {
    return !(*this == rhs);
  }

  bool operator<(const union1& rhs) const {
    if (type_ != rhs.type_) return type_ < rhs.type_;
    switch (type_) {
      case Type::ui: {
        return value_.ui < rhs.value_.ui;

        break;
      }
      case Type::ud: {
        return value_.ud < rhs.value_.ud;

        break;
      }
      case Type::us: {
        return value_.us < rhs.value_.us;

        break;
      }
      case Type::ue: {
        return value_.ue < rhs.value_.ue;

        break;
      }
      default: return false;
    }
    return false;
  }

  template<typename... T>
  void set_ui(T&&... t) {
    __clear();
    type_ = Type::ui;
    new (&value_.ui) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ud(T&&... t) {
    __clear();
    type_ = Type::ud;
    new (&value_.ud) double(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_us(T&&... t) {
    __clear();
    type_ = Type::us;
    new (&value_.us) std::string(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ue(T&&... t) {
    __clear();
    type_ = Type::ue;
    new (&value_.ue) enum1(std::forward<T>(t)...);
  }

  const int32_t& get_ui() const {
    assert(type_ == Type::ui);
    return value_.ui;
  }

  const double& get_ud() const {
    assert(type_ == Type::ud);
    return value_.ud;
  }

  const std::string& get_us() const {
    assert(type_ == Type::us);
    return value_.us;
  }

  const enum1& get_ue() const {
    assert(type_ == Type::ue);
    return value_.ue;
  }

  int32_t& mutable_ui() {
    assert(type_ == Type::ui);
    return value_.ui;
  }

  double& mutable_ud() {
    assert(type_ == Type::ud);
    return value_.ud;
  }

  std::string& mutable_us() {
    assert(type_ == Type::us);
    return value_.us;
  }

  enum1& mutable_ue() {
    assert(type_ == Type::ue);
    return value_.ue;
  }

  int32_t move_ui() {
    assert(type_ == Type::ui);
    return std::move(value_.ui);
  }

  double move_ud() {
    assert(type_ == Type::ud);
    return std::move(value_.ud);
  }

  std::string move_us() {
    assert(type_ == Type::us);
    return std::move(value_.us);
  }

  enum1 move_ue() {
    assert(type_ == Type::ue);
    return std::move(value_.ue);
  }

  Type getType() const { return type_; }

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;
 private:
  Type type_;
  storage_type value_;

};

class union2 : public apache::thrift::TStructType<union2> {
 public:
  enum class Type {
    __EMPTY__ = 0,
    ui_2 = 1,
    ud_2 = 2,
    us_2 = 3,
    ue_2 = 4,
  };

  union2() : type_(Type::__EMPTY__) {}
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union2(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_ui_2(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union2(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_ud_2(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union2(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_us_2(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union2(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_ue_2(arg.move());
  }
  union2(const union2& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui_2: {
        set_ui_2(rhs.value_.ui_2);
        break;
      }
      case Type::ud_2: {
        set_ud_2(rhs.value_.ud_2);
        break;
      }
      case Type::us_2: {
        set_us_2(rhs.value_.us_2);
        break;
      }
      case Type::ue_2: {
        set_ue_2(rhs.value_.ue_2);
        break;
      }
      default: assert(false);
    }
  }

  union2& operator=(const union2& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui_2: {
        set_ui_2(rhs.value_.ui_2);
        break;
      }
      case Type::ud_2: {
        set_ud_2(rhs.value_.ud_2);
        break;
      }
      case Type::us_2: {
        set_us_2(rhs.value_.us_2);
        break;
      }
      case Type::ue_2: {
        set_ue_2(rhs.value_.ue_2);
        break;
      }
      default: assert(false);
    }
    return *this;
  }

  union2(union2&& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui_2: {
        set_ui_2(std::move(rhs.value_.ui_2));
        break;
      }
      case Type::ud_2: {
        set_ud_2(std::move(rhs.value_.ud_2));
        break;
      }
      case Type::us_2: {
        set_us_2(std::move(rhs.value_.us_2));
        break;
      }
      case Type::ue_2: {
        set_ue_2(std::move(rhs.value_.ue_2));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
  }

  union2& operator=(union2&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui_2: {
        set_ui_2(std::move(rhs.value_.ui_2));
        break;
      }
      case Type::ud_2: {
        set_ud_2(std::move(rhs.value_.ud_2));
        break;
      }
      case Type::us_2: {
        set_us_2(std::move(rhs.value_.us_2));
        break;
      }
      case Type::ue_2: {
        set_ue_2(std::move(rhs.value_.ue_2));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
    return *this;
  }


  void __clear() {
    if (type_ == Type::__EMPTY__) { return; }
    switch (type_) {
      case Type::ui_2: {
        
        break;
      }
      case Type::ud_2: {
        
        break;
      }
      case Type::us_2: {
        using namespace std; value_.us_2.~string();
        break;
      }
      case Type::ue_2: {
        value_.ue_2.~enum1();
        break;
      }
      default: assert(false);
    }
    type_ = Type::__EMPTY__;
  }
  virtual ~union2() throw() {
    __clear();
  }

  union storage_type {
    int32_t ui_2;
    double ud_2;
    std::string us_2;
    enum1 ue_2;
    
    storage_type() {}
    ~storage_type() {}
  };

  bool operator==(const union2& rhs) const {
    if (type_ != rhs.type_) { return false; }
    switch (type_) {
      case Type::ui_2: {
        return value_.ui_2 == rhs.value_.ui_2;

        break;
      }
      case Type::ud_2: {
        return value_.ud_2 == rhs.value_.ud_2;

        break;
      }
      case Type::us_2: {
        return value_.us_2 == rhs.value_.us_2;

        break;
      }
      case Type::ue_2: {
        return value_.ue_2 == rhs.value_.ue_2;

        break;
      }
      default: return true;
    }
  }

  bool operator!=(const union2& rhs) const {
    return !(*this == rhs);
  }

  bool operator<(const union2& rhs) const {
    if (type_ != rhs.type_) return type_ < rhs.type_;
    switch (type_) {
      case Type::ui_2: {
        return value_.ui_2 < rhs.value_.ui_2;

        break;
      }
      case Type::ud_2: {
        return value_.ud_2 < rhs.value_.ud_2;

        break;
      }
      case Type::us_2: {
        return value_.us_2 < rhs.value_.us_2;

        break;
      }
      case Type::ue_2: {
        return value_.ue_2 < rhs.value_.ue_2;

        break;
      }
      default: return false;
    }
    return false;
  }

  template<typename... T>
  void set_ui_2(T&&... t) {
    __clear();
    type_ = Type::ui_2;
    new (&value_.ui_2) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ud_2(T&&... t) {
    __clear();
    type_ = Type::ud_2;
    new (&value_.ud_2) double(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_us_2(T&&... t) {
    __clear();
    type_ = Type::us_2;
    new (&value_.us_2) std::string(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ue_2(T&&... t) {
    __clear();
    type_ = Type::ue_2;
    new (&value_.ue_2) enum1(std::forward<T>(t)...);
  }

  const int32_t& get_ui_2() const {
    assert(type_ == Type::ui_2);
    return value_.ui_2;
  }

  const double& get_ud_2() const {
    assert(type_ == Type::ud_2);
    return value_.ud_2;
  }

  const std::string& get_us_2() const {
    assert(type_ == Type::us_2);
    return value_.us_2;
  }

  const enum1& get_ue_2() const {
    assert(type_ == Type::ue_2);
    return value_.ue_2;
  }

  int32_t& mutable_ui_2() {
    assert(type_ == Type::ui_2);
    return value_.ui_2;
  }

  double& mutable_ud_2() {
    assert(type_ == Type::ud_2);
    return value_.ud_2;
  }

  std::string& mutable_us_2() {
    assert(type_ == Type::us_2);
    return value_.us_2;
  }

  enum1& mutable_ue_2() {
    assert(type_ == Type::ue_2);
    return value_.ue_2;
  }

  int32_t move_ui_2() {
    assert(type_ == Type::ui_2);
    return std::move(value_.ui_2);
  }

  double move_ud_2() {
    assert(type_ == Type::ud_2);
    return std::move(value_.ud_2);
  }

  std::string move_us_2() {
    assert(type_ == Type::us_2);
    return std::move(value_.us_2);
  }

  enum1 move_ue_2() {
    assert(type_ == Type::ue_2);
    return std::move(value_.ue_2);
  }

  Type getType() const { return type_; }

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;
 private:
  Type type_;
  storage_type value_;

};

class union3 : public apache::thrift::TStructType<union3> {
 public:
  enum class Type {
    __EMPTY__ = 0,
    ui_3 = 1,
    ud_3 = 2,
    us_3 = 3,
    ue_3 = 4,
  };

  union3() : type_(Type::__EMPTY__) {}
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union3(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_ui_3(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union3(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_ud_3(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union3(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_us_3(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union3(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_ue_3(arg.move());
  }
  union3(const union3& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui_3: {
        set_ui_3(rhs.value_.ui_3);
        break;
      }
      case Type::ud_3: {
        set_ud_3(rhs.value_.ud_3);
        break;
      }
      case Type::us_3: {
        set_us_3(rhs.value_.us_3);
        break;
      }
      case Type::ue_3: {
        set_ue_3(rhs.value_.ue_3);
        break;
      }
      default: assert(false);
    }
  }

  union3& operator=(const union3& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui_3: {
        set_ui_3(rhs.value_.ui_3);
        break;
      }
      case Type::ud_3: {
        set_ud_3(rhs.value_.ud_3);
        break;
      }
      case Type::us_3: {
        set_us_3(rhs.value_.us_3);
        break;
      }
      case Type::ue_3: {
        set_ue_3(rhs.value_.ue_3);
        break;
      }
      default: assert(false);
    }
    return *this;
  }

  union3(union3&& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui_3: {
        set_ui_3(std::move(rhs.value_.ui_3));
        break;
      }
      case Type::ud_3: {
        set_ud_3(std::move(rhs.value_.ud_3));
        break;
      }
      case Type::us_3: {
        set_us_3(std::move(rhs.value_.us_3));
        break;
      }
      case Type::ue_3: {
        set_ue_3(std::move(rhs.value_.ue_3));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
  }

  union3& operator=(union3&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui_3: {
        set_ui_3(std::move(rhs.value_.ui_3));
        break;
      }
      case Type::ud_3: {
        set_ud_3(std::move(rhs.value_.ud_3));
        break;
      }
      case Type::us_3: {
        set_us_3(std::move(rhs.value_.us_3));
        break;
      }
      case Type::ue_3: {
        set_ue_3(std::move(rhs.value_.ue_3));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
    return *this;
  }


  void __clear() {
    if (type_ == Type::__EMPTY__) { return; }
    switch (type_) {
      case Type::ui_3: {
        
        break;
      }
      case Type::ud_3: {
        
        break;
      }
      case Type::us_3: {
        using namespace std; value_.us_3.~string();
        break;
      }
      case Type::ue_3: {
        value_.ue_3.~enum1();
        break;
      }
      default: assert(false);
    }
    type_ = Type::__EMPTY__;
  }
  virtual ~union3() throw() {
    __clear();
  }

  union storage_type {
    int32_t ui_3;
    double ud_3;
    std::string us_3;
    enum1 ue_3;
    
    storage_type() {}
    ~storage_type() {}
  };

  bool operator==(const union3& rhs) const {
    if (type_ != rhs.type_) { return false; }
    switch (type_) {
      case Type::ui_3: {
        return value_.ui_3 == rhs.value_.ui_3;

        break;
      }
      case Type::ud_3: {
        return value_.ud_3 == rhs.value_.ud_3;

        break;
      }
      case Type::us_3: {
        return value_.us_3 == rhs.value_.us_3;

        break;
      }
      case Type::ue_3: {
        return value_.ue_3 == rhs.value_.ue_3;

        break;
      }
      default: return true;
    }
  }

  bool operator!=(const union3& rhs) const {
    return !(*this == rhs);
  }

  bool operator<(const union3& rhs) const {
    if (type_ != rhs.type_) return type_ < rhs.type_;
    switch (type_) {
      case Type::ui_3: {
        return value_.ui_3 < rhs.value_.ui_3;

        break;
      }
      case Type::ud_3: {
        return value_.ud_3 < rhs.value_.ud_3;

        break;
      }
      case Type::us_3: {
        return value_.us_3 < rhs.value_.us_3;

        break;
      }
      case Type::ue_3: {
        return value_.ue_3 < rhs.value_.ue_3;

        break;
      }
      default: return false;
    }
    return false;
  }

  template<typename... T>
  void set_ui_3(T&&... t) {
    __clear();
    type_ = Type::ui_3;
    new (&value_.ui_3) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ud_3(T&&... t) {
    __clear();
    type_ = Type::ud_3;
    new (&value_.ud_3) double(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_us_3(T&&... t) {
    __clear();
    type_ = Type::us_3;
    new (&value_.us_3) std::string(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ue_3(T&&... t) {
    __clear();
    type_ = Type::ue_3;
    new (&value_.ue_3) enum1(std::forward<T>(t)...);
  }

  const int32_t& get_ui_3() const {
    assert(type_ == Type::ui_3);
    return value_.ui_3;
  }

  const double& get_ud_3() const {
    assert(type_ == Type::ud_3);
    return value_.ud_3;
  }

  const std::string& get_us_3() const {
    assert(type_ == Type::us_3);
    return value_.us_3;
  }

  const enum1& get_ue_3() const {
    assert(type_ == Type::ue_3);
    return value_.ue_3;
  }

  int32_t& mutable_ui_3() {
    assert(type_ == Type::ui_3);
    return value_.ui_3;
  }

  double& mutable_ud_3() {
    assert(type_ == Type::ud_3);
    return value_.ud_3;
  }

  std::string& mutable_us_3() {
    assert(type_ == Type::us_3);
    return value_.us_3;
  }

  enum1& mutable_ue_3() {
    assert(type_ == Type::ue_3);
    return value_.ue_3;
  }

  int32_t move_ui_3() {
    assert(type_ == Type::ui_3);
    return std::move(value_.ui_3);
  }

  double move_ud_3() {
    assert(type_ == Type::ud_3);
    return std::move(value_.ud_3);
  }

  std::string move_us_3() {
    assert(type_ == Type::us_3);
    return std::move(value_.us_3);
  }

  enum1 move_ue_3() {
    assert(type_ == Type::ue_3);
    return std::move(value_.ue_3);
  }

  Type getType() const { return type_; }

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;
 private:
  Type type_;
  storage_type value_;

};

void swap(structA &a, structA &b);

class structA : public apache::thrift::TStructType<structA> {
 public:

  static const uint64_t _reflection_id = 9663308154247018828U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  structA() : a(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structA(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structA(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    a = arg.move();
    __isset.a = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structA(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structA(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    b = arg.move();
    __isset.b = true;
  }

  structA(const structA&) = default;
  structA& operator=(const structA& src)= default;
  structA(structA&&) = default;
  structA& operator=(structA&&) = default;

  void __clear();

  virtual ~structA() throw() {}

  int32_t a;
  std::string b;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      a = false;
      b = false;
    }
    bool a;
    bool b;
  } __isset;

  bool operator == (const structA &) const;
  bool operator != (const structA& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const structA & ) const;

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class structA;
void merge(const structA& from, structA& to);
void merge(structA&& from, structA& to);
class unionA : public apache::thrift::TStructType<unionA> {
 public:
  enum class Type {
    __EMPTY__ = 0,
    i = 1,
    d = 2,
    s = 3,
    e = 4,
    a = 5,
  };

  unionA() : type_(Type::__EMPTY__) {}
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit unionA(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_i(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit unionA(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_d(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit unionA(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_s(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit unionA(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_e(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit unionA(
    ::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_a(arg.move());
  }
  unionA(const unionA& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::i: {
        set_i(rhs.value_.i);
        break;
      }
      case Type::d: {
        set_d(rhs.value_.d);
        break;
      }
      case Type::s: {
        set_s(rhs.value_.s);
        break;
      }
      case Type::e: {
        set_e(rhs.value_.e);
        break;
      }
      case Type::a: {
        set_a(rhs.value_.a);
        break;
      }
      default: assert(false);
    }
  }

  unionA& operator=(const unionA& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::i: {
        set_i(rhs.value_.i);
        break;
      }
      case Type::d: {
        set_d(rhs.value_.d);
        break;
      }
      case Type::s: {
        set_s(rhs.value_.s);
        break;
      }
      case Type::e: {
        set_e(rhs.value_.e);
        break;
      }
      case Type::a: {
        set_a(rhs.value_.a);
        break;
      }
      default: assert(false);
    }
    return *this;
  }

  unionA(unionA&& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::i: {
        set_i(std::move(rhs.value_.i));
        break;
      }
      case Type::d: {
        set_d(std::move(rhs.value_.d));
        break;
      }
      case Type::s: {
        set_s(std::move(rhs.value_.s));
        break;
      }
      case Type::e: {
        set_e(std::move(rhs.value_.e));
        break;
      }
      case Type::a: {
        set_a(std::move(rhs.value_.a));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
  }

  unionA& operator=(unionA&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::i: {
        set_i(std::move(rhs.value_.i));
        break;
      }
      case Type::d: {
        set_d(std::move(rhs.value_.d));
        break;
      }
      case Type::s: {
        set_s(std::move(rhs.value_.s));
        break;
      }
      case Type::e: {
        set_e(std::move(rhs.value_.e));
        break;
      }
      case Type::a: {
        set_a(std::move(rhs.value_.a));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
    return *this;
  }


  void __clear() {
    if (type_ == Type::__EMPTY__) { return; }
    switch (type_) {
      case Type::i: {
        
        break;
      }
      case Type::d: {
        
        break;
      }
      case Type::s: {
        using namespace std; value_.s.~string();
        break;
      }
      case Type::e: {
        value_.e.~enum1();
        break;
      }
      case Type::a: {
        value_.a.~structA();
        break;
      }
      default: assert(false);
    }
    type_ = Type::__EMPTY__;
  }
  virtual ~unionA() throw() {
    __clear();
  }

  union storage_type {
    int32_t i;
    double d;
    std::string s;
    enum1 e;
    structA a;
    
    storage_type() {}
    ~storage_type() {}
  };

  bool operator==(const unionA& rhs) const {
    if (type_ != rhs.type_) { return false; }
    switch (type_) {
      case Type::i: {
        return value_.i == rhs.value_.i;

        break;
      }
      case Type::d: {
        return value_.d == rhs.value_.d;

        break;
      }
      case Type::s: {
        return value_.s == rhs.value_.s;

        break;
      }
      case Type::e: {
        return value_.e == rhs.value_.e;

        break;
      }
      case Type::a: {
        return value_.a == rhs.value_.a;

        break;
      }
      default: return true;
    }
  }

  bool operator!=(const unionA& rhs) const {
    return !(*this == rhs);
  }

  bool operator<(const unionA& rhs) const {
    if (type_ != rhs.type_) return type_ < rhs.type_;
    switch (type_) {
      case Type::i: {
        return value_.i < rhs.value_.i;

        break;
      }
      case Type::d: {
        return value_.d < rhs.value_.d;

        break;
      }
      case Type::s: {
        return value_.s < rhs.value_.s;

        break;
      }
      case Type::e: {
        return value_.e < rhs.value_.e;

        break;
      }
      case Type::a: {
        return value_.a < rhs.value_.a;

        break;
      }
      default: return false;
    }
    return false;
  }

  template<typename... T>
  void set_i(T&&... t) {
    __clear();
    type_ = Type::i;
    new (&value_.i) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_d(T&&... t) {
    __clear();
    type_ = Type::d;
    new (&value_.d) double(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_s(T&&... t) {
    __clear();
    type_ = Type::s;
    new (&value_.s) std::string(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_e(T&&... t) {
    __clear();
    type_ = Type::e;
    new (&value_.e) enum1(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_a(T&&... t) {
    __clear();
    type_ = Type::a;
    new (&value_.a) structA(std::forward<T>(t)...);
  }

  const int32_t& get_i() const {
    assert(type_ == Type::i);
    return value_.i;
  }

  const double& get_d() const {
    assert(type_ == Type::d);
    return value_.d;
  }

  const std::string& get_s() const {
    assert(type_ == Type::s);
    return value_.s;
  }

  const enum1& get_e() const {
    assert(type_ == Type::e);
    return value_.e;
  }

  const structA& get_a() const {
    assert(type_ == Type::a);
    return value_.a;
  }

  int32_t& mutable_i() {
    assert(type_ == Type::i);
    return value_.i;
  }

  double& mutable_d() {
    assert(type_ == Type::d);
    return value_.d;
  }

  std::string& mutable_s() {
    assert(type_ == Type::s);
    return value_.s;
  }

  enum1& mutable_e() {
    assert(type_ == Type::e);
    return value_.e;
  }

  structA& mutable_a() {
    assert(type_ == Type::a);
    return value_.a;
  }

  int32_t move_i() {
    assert(type_ == Type::i);
    return std::move(value_.i);
  }

  double move_d() {
    assert(type_ == Type::d);
    return std::move(value_.d);
  }

  std::string move_s() {
    assert(type_ == Type::s);
    return std::move(value_.s);
  }

  enum1 move_e() {
    assert(type_ == Type::e);
    return std::move(value_.e);
  }

  structA move_a() {
    assert(type_ == Type::a);
    return std::move(value_.a);
  }

  Type getType() const { return type_; }

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;
 private:
  Type type_;
  storage_type value_;

};

void swap(structB &a, structB &b);

class structB : public apache::thrift::TStructType<structB> {
 public:

  static const uint64_t _reflection_id = 10239267202130913964U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  structB() : c(0), d(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structB(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structB(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    c = arg.move();
    __isset.c = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structB(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structB(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    d = arg.move();
    __isset.d = true;
  }

  structB(const structB&) = default;
  structB& operator=(const structB& src)= default;
  structB(structB&&) = default;
  structB& operator=(structB&&) = default;

  void __clear();

  virtual ~structB() throw() {}

  double c;
  bool d;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      c = false;
      d = false;
    }
    bool c;
    bool d;
  } __isset;

  bool operator == (const structB &) const;
  bool operator != (const structB& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const structB & ) const;

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class structB;
void merge(const structB& from, structB& to);
void merge(structB&& from, structB& to);
void swap(structC &a, structC &b);

class structC : public apache::thrift::TStructType<structC> {
 public:

  static const uint64_t _reflection_id = 18130273386912691148U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  structC() : a(0), c(0), d(0), e(static_cast<enum1>(0)), f(static_cast<enum2>(0)) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    a = arg.move();
    __isset.a = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    b = arg.move();
    __isset.b = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    c = arg.move();
    __isset.c = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    d = arg.move();
    __isset.d = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    e = arg.move();
    __isset.e = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    f = arg.move();
    __isset.f = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<7, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    g = arg.move();
    __isset.g = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<8, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    h = arg.move();
    __isset.h = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<9, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    i = arg.move();
    __isset.i = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<10, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    j = arg.move();
    __isset.j = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<11, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    j1 = arg.move();
    __isset.j1 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<12, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    j2 = arg.move();
    __isset.j2 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<13, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    j3 = arg.move();
    __isset.j3 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<14, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    k = arg.move();
    __isset.k = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<15, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    k1 = arg.move();
    __isset.k1 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<16, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    k2 = arg.move();
    __isset.k2 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<17, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    k3 = arg.move();
    __isset.k3 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<18, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    l = arg.move();
    __isset.l = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<19, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    l1 = arg.move();
    __isset.l1 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<20, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    l2 = arg.move();
    __isset.l2 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<21, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    l3 = arg.move();
    __isset.l3 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<22, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    m1 = arg.move();
    __isset.m1 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<23, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    m2 = arg.move();
    __isset.m2 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<24, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    m3 = arg.move();
    __isset.m3 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<25, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    n1 = arg.move();
    __isset.n1 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<26, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    n2 = arg.move();
    __isset.n2 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<27, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    n3 = arg.move();
    __isset.n3 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<28, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    o1 = arg.move();
    __isset.o1 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<29, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    o2 = arg.move();
    __isset.o2 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit structC(
    ::apache::thrift::detail::argument_wrapper<30, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    structC(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    o3 = arg.move();
    __isset.o3 = true;
  }

  structC(const structC&) = default;
  structC& operator=(const structC& src)= default;
  structC(structC&&) = default;
  structC& operator=(structC&&) = default;

  void __clear();

  virtual ~structC() throw() {}

  int32_t a;
  std::string b;
  double c;
  bool d;
  enum1 e;
  enum2 f;
  union1 g;
  unionA h;
  unionA i;
  std::vector<int32_t>  j;
  std::vector<int32_t>  j1;
  std::vector<enum1>  j2;
  std::vector<structA>  j3;
  std::set<int32_t>  k;
  std::set<int32_t>  k1;
  std::set<enum2>  k2;
  std::set<structB>  k3;
  std::map<int32_t, int32_t>  l;
  std::map<int32_t, int32_t>  l1;
  std::map<int32_t, enum1>  l2;
  std::map<int32_t, structB>  l3;
  std::map<enum1, int32_t>  m1;
  std::map<enum1, enum2>  m2;
  std::map<enum1, structB>  m3;
  std::map<std::string, int32_t>  n1;
  std::map<std::string, enum1>  n2;
  std::map<std::string, structB>  n3;
  std::map<structA, int32_t>  o1;
  std::map<structA, enum1>  o2;
  std::map<structA, structB>  o3;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      a = false;
      b = false;
      c = false;
      d = false;
      e = false;
      f = false;
      g = false;
      h = false;
      i = false;
      j = false;
      j1 = false;
      j2 = false;
      j3 = false;
      k = false;
      k1 = false;
      k2 = false;
      k3 = false;
      l = false;
      l1 = false;
      l2 = false;
      l3 = false;
      m1 = false;
      m2 = false;
      m3 = false;
      n1 = false;
      n2 = false;
      n3 = false;
      o1 = false;
      o2 = false;
      o3 = false;
    }
    bool a;
    bool b;
    bool c;
    bool d;
    bool e;
    bool f;
    bool g;
    bool h;
    bool i;
    bool j;
    bool j1;
    bool j2;
    bool j3;
    bool k;
    bool k1;
    bool k2;
    bool k3;
    bool l;
    bool l1;
    bool l2;
    bool l3;
    bool m1;
    bool m2;
    bool m3;
    bool n1;
    bool n2;
    bool n3;
    bool o1;
    bool o2;
    bool o3;
  } __isset;

  bool operator == (const structC &) const;
  bool operator != (const structC& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const structC & ) const;

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class structC;
void merge(const structC& from, structC& to);
void merge(structC&& from, structC& to);
void swap(struct1 &a, struct1 &b);

class struct1 : public apache::thrift::TStructType<struct1> {
 public:

  static const uint64_t _reflection_id = 18317194148543753228U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  struct1() : field0(0), field2(static_cast<enum1>(0)), field3(static_cast<enum2>(0)) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct1(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct1(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field0 = arg.move();
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct1(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct1(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field1 = arg.move();
    __isset.field1 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct1(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct1(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field2 = arg.move();
    __isset.field2 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct1(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct1(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field3 = arg.move();
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct1(
    ::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct1(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field4 = arg.move();
    __isset.field4 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct1(
    ::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct1(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field5 = arg.move();
    __isset.field5 = true;
  }

  struct1(const struct1&) = default;
  struct1& operator=(const struct1& src)= default;
  struct1(struct1&&) = default;
  struct1& operator=(struct1&&) = default;

  void __clear();

  virtual ~struct1() throw() {}

  int32_t field0;
  std::string field1;
  enum1 field2;
  enum2 field3;
  union1 field4;
  union2 field5;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      field1 = false;
      field2 = false;
      field4 = false;
      field5 = false;
    }
    bool field1;
    bool field2;
    bool field4;
    bool field5;
  } __isset;

  bool operator == (const struct1 &) const;
  bool operator != (const struct1& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const struct1 & ) const;

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class struct1;
void merge(const struct1& from, struct1& to);
void merge(struct1&& from, struct1& to);
void swap(struct2 &a, struct2 &b);

class struct2 : public apache::thrift::TStructType<struct2> {
 public:

  static const uint64_t _reflection_id = 13919930284671800588U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  struct2() : fieldA(0), fieldC(static_cast<enum1>(0)), fieldD(static_cast<enum2>(0)) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct2(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct2(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldA = arg.move();
    __isset.fieldA = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct2(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct2(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldB = arg.move();
    __isset.fieldB = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct2(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct2(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldC = arg.move();
    __isset.fieldC = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct2(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct2(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldD = arg.move();
    __isset.fieldD = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct2(
    ::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct2(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldE = arg.move();
    __isset.fieldE = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct2(
    ::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct2(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldF = arg.move();
    __isset.fieldF = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct2(
    ::apache::thrift::detail::argument_wrapper<7, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct2(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldG = arg.move();
    __isset.fieldG = true;
  }

  struct2(const struct2&) = default;
  struct2& operator=(const struct2& src)= default;
  struct2(struct2&&) = default;
  struct2& operator=(struct2&&) = default;

  void __clear();

  virtual ~struct2() throw() {}

  int32_t fieldA;
  std::string fieldB;
  enum1 fieldC;
  enum2 fieldD;
  union1 fieldE;
  union2 fieldF;
  struct1 fieldG;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      fieldA = false;
      fieldB = false;
      fieldC = false;
      fieldD = false;
      fieldE = false;
      fieldF = false;
      fieldG = false;
    }
    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
  } __isset;

  bool operator == (const struct2 &) const;
  bool operator != (const struct2& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const struct2 & ) const;

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class struct2;
void merge(const struct2& from, struct2& to);
void merge(struct2&& from, struct2& to);
void swap(struct3 &a, struct3 &b);

class struct3 : public apache::thrift::TStructType<struct3> {
 public:

  static const uint64_t _reflection_id = 16392874475279945260U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  struct3() : fieldA(0), fieldC(static_cast<enum1>(0)), fieldD(static_cast<enum2>(0)) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldA = arg.move();
    __isset.fieldA = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldB = arg.move();
    __isset.fieldB = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldC = arg.move();
    __isset.fieldC = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldD = arg.move();
    __isset.fieldD = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldE = arg.move();
    __isset.fieldE = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldF = arg.move();
    __isset.fieldF = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<7, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldG = arg.move();
    __isset.fieldG = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<8, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldH = arg.move();
    __isset.fieldH = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<9, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldI = arg.move();
    __isset.fieldI = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<10, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldJ = arg.move();
    __isset.fieldJ = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<11, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldK = arg.move();
    __isset.fieldK = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<12, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldL = arg.move();
    __isset.fieldL = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<13, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldM = arg.move();
    __isset.fieldM = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<14, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldN = arg.move();
    __isset.fieldN = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<15, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldO = arg.move();
    __isset.fieldO = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<16, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldP = arg.move();
    __isset.fieldP = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<17, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldQ = arg.move();
    __isset.fieldQ = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct3(
    ::apache::thrift::detail::argument_wrapper<18, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct3(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldR = arg.move();
    __isset.fieldR = true;
  }

  struct3(const struct3&) = default;
  struct3& operator=(const struct3& src)= default;
  struct3(struct3&&) = default;
  struct3& operator=(struct3&&) = default;

  void __clear();

  virtual ~struct3() throw() {}

  int32_t fieldA;
  std::string fieldB;
  enum1 fieldC;
  enum2 fieldD;
  union1 fieldE;
  union2 fieldF;
  struct1 fieldG;
  union2 fieldH;
  std::vector<int32_t>  fieldI;
  std::vector<std::string>  fieldJ;
  std::vector<std::string>  fieldK;
  std::vector<structA>  fieldL;
  std::set<int32_t>  fieldM;
  std::set<std::string>  fieldN;
  std::set<std::string>  fieldO;
  std::set<structB>  fieldP;
  std::map<std::string, structA>  fieldQ;
  std::map<std::string, structB>  fieldR;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      fieldA = false;
      fieldB = false;
      fieldC = false;
      fieldD = false;
      fieldE = false;
      fieldF = false;
      fieldG = false;
      fieldH = false;
      fieldI = false;
      fieldJ = false;
      fieldK = false;
      fieldL = false;
      fieldM = false;
      fieldN = false;
      fieldO = false;
      fieldP = false;
      fieldQ = false;
      fieldR = false;
    }
    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
    bool fieldH;
    bool fieldI;
    bool fieldJ;
    bool fieldK;
    bool fieldL;
    bool fieldM;
    bool fieldN;
    bool fieldO;
    bool fieldP;
    bool fieldQ;
    bool fieldR;
  } __isset;

  bool operator == (const struct3 &) const;
  bool operator != (const struct3& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const struct3 & ) const;

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class struct3;
void merge(const struct3& from, struct3& to);
void merge(struct3&& from, struct3& to);
void swap(struct4 &a, struct4 &b);

class struct4 : public apache::thrift::TStructType<struct4> {
 public:

  static const uint64_t _reflection_id = 7898252530621438604U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  struct4() : field0(0), field2(static_cast<enum1>(0)) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct4(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct4(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field0 = arg.move();
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct4(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct4(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field1 = arg.move();
    __isset.field1 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct4(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct4(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field2 = arg.move();
    __isset.field2 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct4(
    ::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct4(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field3 = arg.move();
    __isset.field3 = true;
  }

  struct4(const struct4&) = default;
  struct4& operator=(const struct4& src)= default;
  struct4(struct4&&) = default;
  struct4& operator=(struct4&&) = default;

  void __clear();

  virtual ~struct4() throw() {}

  int32_t field0;
  std::string field1;
  enum1 field2;
  structA field3;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      field1 = false;
      field2 = false;
      field3 = false;
    }
    bool field1;
    bool field2;
    bool field3;
  } __isset;

  bool operator == (const struct4 &) const;
  bool operator != (const struct4& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const struct4 & ) const;

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class struct4;
void merge(const struct4& from, struct4& to);
void merge(struct4&& from, struct4& to);
void swap(struct5 &a, struct5 &b);

class struct5 : public apache::thrift::TStructType<struct5> {
 public:

  static const uint64_t _reflection_id = 16358384009565610188U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  struct5() : field0(0), field2(static_cast<enum1>(0)) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct5(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct5(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field0 = arg.move();
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct5(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct5(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field1 = arg.move();
    __isset.field1 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct5(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct5(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field2 = arg.move();
    __isset.field2 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct5(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct5(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field3 = arg.move();
    __isset.field3 = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct5(
    ::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct5(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field4 = arg.move();
    __isset.field4 = true;
  }

  struct5(const struct5&) = default;
  struct5& operator=(const struct5& src)= default;
  struct5(struct5&&) = default;
  struct5& operator=(struct5&&) = default;

  void __clear();

  virtual ~struct5() throw() {}

  int32_t field0;
  std::string field1;
  enum1 field2;
  structA field3;
  structB field4;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      field1 = false;
      field2 = false;
      field3 = false;
      field4 = false;
    }
    bool field1;
    bool field2;
    bool field3;
    bool field4;
  } __isset;

  bool operator == (const struct5 &) const;
  bool operator != (const struct5& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const struct5 & ) const;

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class struct5;
void merge(const struct5& from, struct5& to);
void merge(struct5&& from, struct5& to);
void swap(struct_binary &a, struct_binary &b);

class struct_binary : public apache::thrift::TStructType<struct_binary> {
 public:

  static const uint64_t _reflection_id = 6812073435240150444U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  struct_binary() {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_binary(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_binary(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    bi = arg.move();
    __isset.bi = true;
  }

  struct_binary(const struct_binary&) = default;
  struct_binary& operator=(const struct_binary& src)= default;
  struct_binary(struct_binary&&) = default;
  struct_binary& operator=(struct_binary&&) = default;

  void __clear();

  virtual ~struct_binary() throw() {}

  std::string bi;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      bi = false;
    }
    bool bi;
  } __isset;

  bool operator == (const struct_binary &) const;
  bool operator != (const struct_binary& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const struct_binary & ) const;

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class struct_binary;
void merge(const struct_binary& from, struct_binary& to);
void merge(struct_binary&& from, struct_binary& to);
void swap(annotated &a, annotated &b);

class annotated : public apache::thrift::TStructType<annotated> {
 public:

  static const uint64_t _reflection_id = 300598955218934796U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  annotated() : a(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit annotated(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    annotated(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    a = arg.move();
    __isset.a = true;
  }

  annotated(const annotated&) = default;
  annotated& operator=(const annotated& src)= default;
  annotated(annotated&&) = default;
  annotated& operator=(annotated&&) = default;

  void __clear();

  virtual ~annotated() throw() {}

  int32_t a;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      a = false;
    }
    bool a;
  } __isset;

  bool operator == (const annotated &) const;
  bool operator != (const annotated& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const annotated & ) const;

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class annotated;
void merge(const annotated& from, annotated& to);
void merge(annotated&& from, annotated& to);
class union_with_special_names : public apache::thrift::TStructType<union_with_special_names> {
 public:
  enum class Type {
    __EMPTY__ = 0,
    get = 1,
    getter = 2,
    lists = 3,
    maps = 4,
    name = 5,
    name_to_value = 6,
    names = 7,
    prefix_tree = 8,
    sets = 9,
    setter = 10,
    str = 11,
    strings = 12,
    type = 13,
    value = 14,
    value_to_name = 15,
    values = 16,
    id = 17,
    ids = 18,
    descriptor = 19,
    descriptors = 20,
    key = 21,
    keys = 22,
    annotation = 23,
    annotations = 24,
    member = 25,
    members = 26,
  };

  union_with_special_names() : type_(Type::__EMPTY__) {}
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_get(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_getter(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_lists(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_maps(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_name(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_name_to_value(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<7, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_names(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<8, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_prefix_tree(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<9, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_sets(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<10, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_setter(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<11, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_str(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<12, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_strings(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<13, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_type(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<14, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_value(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<15, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_value_to_name(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<16, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_values(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<17, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_id(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<18, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_ids(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<19, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_descriptor(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<20, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_descriptors(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<21, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_key(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<22, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_keys(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<23, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_annotation(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<24, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_annotations(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<25, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_member(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit union_with_special_names(
    ::apache::thrift::detail::argument_wrapper<26, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_members(arg.move());
  }
  union_with_special_names(const union_with_special_names& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::get: {
        set_get(rhs.value_.get);
        break;
      }
      case Type::getter: {
        set_getter(rhs.value_.getter);
        break;
      }
      case Type::lists: {
        set_lists(rhs.value_.lists);
        break;
      }
      case Type::maps: {
        set_maps(rhs.value_.maps);
        break;
      }
      case Type::name: {
        set_name(rhs.value_.name);
        break;
      }
      case Type::name_to_value: {
        set_name_to_value(rhs.value_.name_to_value);
        break;
      }
      case Type::names: {
        set_names(rhs.value_.names);
        break;
      }
      case Type::prefix_tree: {
        set_prefix_tree(rhs.value_.prefix_tree);
        break;
      }
      case Type::sets: {
        set_sets(rhs.value_.sets);
        break;
      }
      case Type::setter: {
        set_setter(rhs.value_.setter);
        break;
      }
      case Type::str: {
        set_str(rhs.value_.str);
        break;
      }
      case Type::strings: {
        set_strings(rhs.value_.strings);
        break;
      }
      case Type::type: {
        set_type(rhs.value_.type);
        break;
      }
      case Type::value: {
        set_value(rhs.value_.value);
        break;
      }
      case Type::value_to_name: {
        set_value_to_name(rhs.value_.value_to_name);
        break;
      }
      case Type::values: {
        set_values(rhs.value_.values);
        break;
      }
      case Type::id: {
        set_id(rhs.value_.id);
        break;
      }
      case Type::ids: {
        set_ids(rhs.value_.ids);
        break;
      }
      case Type::descriptor: {
        set_descriptor(rhs.value_.descriptor);
        break;
      }
      case Type::descriptors: {
        set_descriptors(rhs.value_.descriptors);
        break;
      }
      case Type::key: {
        set_key(rhs.value_.key);
        break;
      }
      case Type::keys: {
        set_keys(rhs.value_.keys);
        break;
      }
      case Type::annotation: {
        set_annotation(rhs.value_.annotation);
        break;
      }
      case Type::annotations: {
        set_annotations(rhs.value_.annotations);
        break;
      }
      case Type::member: {
        set_member(rhs.value_.member);
        break;
      }
      case Type::members: {
        set_members(rhs.value_.members);
        break;
      }
      default: assert(false);
    }
  }

  union_with_special_names& operator=(const union_with_special_names& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::get: {
        set_get(rhs.value_.get);
        break;
      }
      case Type::getter: {
        set_getter(rhs.value_.getter);
        break;
      }
      case Type::lists: {
        set_lists(rhs.value_.lists);
        break;
      }
      case Type::maps: {
        set_maps(rhs.value_.maps);
        break;
      }
      case Type::name: {
        set_name(rhs.value_.name);
        break;
      }
      case Type::name_to_value: {
        set_name_to_value(rhs.value_.name_to_value);
        break;
      }
      case Type::names: {
        set_names(rhs.value_.names);
        break;
      }
      case Type::prefix_tree: {
        set_prefix_tree(rhs.value_.prefix_tree);
        break;
      }
      case Type::sets: {
        set_sets(rhs.value_.sets);
        break;
      }
      case Type::setter: {
        set_setter(rhs.value_.setter);
        break;
      }
      case Type::str: {
        set_str(rhs.value_.str);
        break;
      }
      case Type::strings: {
        set_strings(rhs.value_.strings);
        break;
      }
      case Type::type: {
        set_type(rhs.value_.type);
        break;
      }
      case Type::value: {
        set_value(rhs.value_.value);
        break;
      }
      case Type::value_to_name: {
        set_value_to_name(rhs.value_.value_to_name);
        break;
      }
      case Type::values: {
        set_values(rhs.value_.values);
        break;
      }
      case Type::id: {
        set_id(rhs.value_.id);
        break;
      }
      case Type::ids: {
        set_ids(rhs.value_.ids);
        break;
      }
      case Type::descriptor: {
        set_descriptor(rhs.value_.descriptor);
        break;
      }
      case Type::descriptors: {
        set_descriptors(rhs.value_.descriptors);
        break;
      }
      case Type::key: {
        set_key(rhs.value_.key);
        break;
      }
      case Type::keys: {
        set_keys(rhs.value_.keys);
        break;
      }
      case Type::annotation: {
        set_annotation(rhs.value_.annotation);
        break;
      }
      case Type::annotations: {
        set_annotations(rhs.value_.annotations);
        break;
      }
      case Type::member: {
        set_member(rhs.value_.member);
        break;
      }
      case Type::members: {
        set_members(rhs.value_.members);
        break;
      }
      default: assert(false);
    }
    return *this;
  }

  union_with_special_names(union_with_special_names&& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::get: {
        set_get(std::move(rhs.value_.get));
        break;
      }
      case Type::getter: {
        set_getter(std::move(rhs.value_.getter));
        break;
      }
      case Type::lists: {
        set_lists(std::move(rhs.value_.lists));
        break;
      }
      case Type::maps: {
        set_maps(std::move(rhs.value_.maps));
        break;
      }
      case Type::name: {
        set_name(std::move(rhs.value_.name));
        break;
      }
      case Type::name_to_value: {
        set_name_to_value(std::move(rhs.value_.name_to_value));
        break;
      }
      case Type::names: {
        set_names(std::move(rhs.value_.names));
        break;
      }
      case Type::prefix_tree: {
        set_prefix_tree(std::move(rhs.value_.prefix_tree));
        break;
      }
      case Type::sets: {
        set_sets(std::move(rhs.value_.sets));
        break;
      }
      case Type::setter: {
        set_setter(std::move(rhs.value_.setter));
        break;
      }
      case Type::str: {
        set_str(std::move(rhs.value_.str));
        break;
      }
      case Type::strings: {
        set_strings(std::move(rhs.value_.strings));
        break;
      }
      case Type::type: {
        set_type(std::move(rhs.value_.type));
        break;
      }
      case Type::value: {
        set_value(std::move(rhs.value_.value));
        break;
      }
      case Type::value_to_name: {
        set_value_to_name(std::move(rhs.value_.value_to_name));
        break;
      }
      case Type::values: {
        set_values(std::move(rhs.value_.values));
        break;
      }
      case Type::id: {
        set_id(std::move(rhs.value_.id));
        break;
      }
      case Type::ids: {
        set_ids(std::move(rhs.value_.ids));
        break;
      }
      case Type::descriptor: {
        set_descriptor(std::move(rhs.value_.descriptor));
        break;
      }
      case Type::descriptors: {
        set_descriptors(std::move(rhs.value_.descriptors));
        break;
      }
      case Type::key: {
        set_key(std::move(rhs.value_.key));
        break;
      }
      case Type::keys: {
        set_keys(std::move(rhs.value_.keys));
        break;
      }
      case Type::annotation: {
        set_annotation(std::move(rhs.value_.annotation));
        break;
      }
      case Type::annotations: {
        set_annotations(std::move(rhs.value_.annotations));
        break;
      }
      case Type::member: {
        set_member(std::move(rhs.value_.member));
        break;
      }
      case Type::members: {
        set_members(std::move(rhs.value_.members));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
  }

  union_with_special_names& operator=(union_with_special_names&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::get: {
        set_get(std::move(rhs.value_.get));
        break;
      }
      case Type::getter: {
        set_getter(std::move(rhs.value_.getter));
        break;
      }
      case Type::lists: {
        set_lists(std::move(rhs.value_.lists));
        break;
      }
      case Type::maps: {
        set_maps(std::move(rhs.value_.maps));
        break;
      }
      case Type::name: {
        set_name(std::move(rhs.value_.name));
        break;
      }
      case Type::name_to_value: {
        set_name_to_value(std::move(rhs.value_.name_to_value));
        break;
      }
      case Type::names: {
        set_names(std::move(rhs.value_.names));
        break;
      }
      case Type::prefix_tree: {
        set_prefix_tree(std::move(rhs.value_.prefix_tree));
        break;
      }
      case Type::sets: {
        set_sets(std::move(rhs.value_.sets));
        break;
      }
      case Type::setter: {
        set_setter(std::move(rhs.value_.setter));
        break;
      }
      case Type::str: {
        set_str(std::move(rhs.value_.str));
        break;
      }
      case Type::strings: {
        set_strings(std::move(rhs.value_.strings));
        break;
      }
      case Type::type: {
        set_type(std::move(rhs.value_.type));
        break;
      }
      case Type::value: {
        set_value(std::move(rhs.value_.value));
        break;
      }
      case Type::value_to_name: {
        set_value_to_name(std::move(rhs.value_.value_to_name));
        break;
      }
      case Type::values: {
        set_values(std::move(rhs.value_.values));
        break;
      }
      case Type::id: {
        set_id(std::move(rhs.value_.id));
        break;
      }
      case Type::ids: {
        set_ids(std::move(rhs.value_.ids));
        break;
      }
      case Type::descriptor: {
        set_descriptor(std::move(rhs.value_.descriptor));
        break;
      }
      case Type::descriptors: {
        set_descriptors(std::move(rhs.value_.descriptors));
        break;
      }
      case Type::key: {
        set_key(std::move(rhs.value_.key));
        break;
      }
      case Type::keys: {
        set_keys(std::move(rhs.value_.keys));
        break;
      }
      case Type::annotation: {
        set_annotation(std::move(rhs.value_.annotation));
        break;
      }
      case Type::annotations: {
        set_annotations(std::move(rhs.value_.annotations));
        break;
      }
      case Type::member: {
        set_member(std::move(rhs.value_.member));
        break;
      }
      case Type::members: {
        set_members(std::move(rhs.value_.members));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
    return *this;
  }


  void __clear() {
    if (type_ == Type::__EMPTY__) { return; }
    switch (type_) {
      case Type::get: {
        
        break;
      }
      case Type::getter: {
        
        break;
      }
      case Type::lists: {
        
        break;
      }
      case Type::maps: {
        
        break;
      }
      case Type::name: {
        
        break;
      }
      case Type::name_to_value: {
        
        break;
      }
      case Type::names: {
        
        break;
      }
      case Type::prefix_tree: {
        
        break;
      }
      case Type::sets: {
        
        break;
      }
      case Type::setter: {
        
        break;
      }
      case Type::str: {
        
        break;
      }
      case Type::strings: {
        
        break;
      }
      case Type::type: {
        
        break;
      }
      case Type::value: {
        
        break;
      }
      case Type::value_to_name: {
        
        break;
      }
      case Type::values: {
        
        break;
      }
      case Type::id: {
        
        break;
      }
      case Type::ids: {
        
        break;
      }
      case Type::descriptor: {
        
        break;
      }
      case Type::descriptors: {
        
        break;
      }
      case Type::key: {
        
        break;
      }
      case Type::keys: {
        
        break;
      }
      case Type::annotation: {
        
        break;
      }
      case Type::annotations: {
        
        break;
      }
      case Type::member: {
        
        break;
      }
      case Type::members: {
        
        break;
      }
      default: assert(false);
    }
    type_ = Type::__EMPTY__;
  }
  virtual ~union_with_special_names() throw() {
    __clear();
  }

  union storage_type {
    int32_t get;
    int32_t getter;
    int32_t lists;
    int32_t maps;
    int32_t name;
    int32_t name_to_value;
    int32_t names;
    int32_t prefix_tree;
    int32_t sets;
    int32_t setter;
    int32_t str;
    int32_t strings;
    int32_t type;
    int32_t value;
    int32_t value_to_name;
    int32_t values;
    int32_t id;
    int32_t ids;
    int32_t descriptor;
    int32_t descriptors;
    int32_t key;
    int32_t keys;
    int32_t annotation;
    int32_t annotations;
    int32_t member;
    int32_t members;
    
    storage_type() {}
    ~storage_type() {}
  };

  bool operator==(const union_with_special_names& rhs) const {
    if (type_ != rhs.type_) { return false; }
    switch (type_) {
      case Type::get: {
        return value_.get == rhs.value_.get;

        break;
      }
      case Type::getter: {
        return value_.getter == rhs.value_.getter;

        break;
      }
      case Type::lists: {
        return value_.lists == rhs.value_.lists;

        break;
      }
      case Type::maps: {
        return value_.maps == rhs.value_.maps;

        break;
      }
      case Type::name: {
        return value_.name == rhs.value_.name;

        break;
      }
      case Type::name_to_value: {
        return value_.name_to_value == rhs.value_.name_to_value;

        break;
      }
      case Type::names: {
        return value_.names == rhs.value_.names;

        break;
      }
      case Type::prefix_tree: {
        return value_.prefix_tree == rhs.value_.prefix_tree;

        break;
      }
      case Type::sets: {
        return value_.sets == rhs.value_.sets;

        break;
      }
      case Type::setter: {
        return value_.setter == rhs.value_.setter;

        break;
      }
      case Type::str: {
        return value_.str == rhs.value_.str;

        break;
      }
      case Type::strings: {
        return value_.strings == rhs.value_.strings;

        break;
      }
      case Type::type: {
        return value_.type == rhs.value_.type;

        break;
      }
      case Type::value: {
        return value_.value == rhs.value_.value;

        break;
      }
      case Type::value_to_name: {
        return value_.value_to_name == rhs.value_.value_to_name;

        break;
      }
      case Type::values: {
        return value_.values == rhs.value_.values;

        break;
      }
      case Type::id: {
        return value_.id == rhs.value_.id;

        break;
      }
      case Type::ids: {
        return value_.ids == rhs.value_.ids;

        break;
      }
      case Type::descriptor: {
        return value_.descriptor == rhs.value_.descriptor;

        break;
      }
      case Type::descriptors: {
        return value_.descriptors == rhs.value_.descriptors;

        break;
      }
      case Type::key: {
        return value_.key == rhs.value_.key;

        break;
      }
      case Type::keys: {
        return value_.keys == rhs.value_.keys;

        break;
      }
      case Type::annotation: {
        return value_.annotation == rhs.value_.annotation;

        break;
      }
      case Type::annotations: {
        return value_.annotations == rhs.value_.annotations;

        break;
      }
      case Type::member: {
        return value_.member == rhs.value_.member;

        break;
      }
      case Type::members: {
        return value_.members == rhs.value_.members;

        break;
      }
      default: return true;
    }
  }

  bool operator!=(const union_with_special_names& rhs) const {
    return !(*this == rhs);
  }

  bool operator<(const union_with_special_names& rhs) const {
    if (type_ != rhs.type_) return type_ < rhs.type_;
    switch (type_) {
      case Type::get: {
        return value_.get < rhs.value_.get;

        break;
      }
      case Type::getter: {
        return value_.getter < rhs.value_.getter;

        break;
      }
      case Type::lists: {
        return value_.lists < rhs.value_.lists;

        break;
      }
      case Type::maps: {
        return value_.maps < rhs.value_.maps;

        break;
      }
      case Type::name: {
        return value_.name < rhs.value_.name;

        break;
      }
      case Type::name_to_value: {
        return value_.name_to_value < rhs.value_.name_to_value;

        break;
      }
      case Type::names: {
        return value_.names < rhs.value_.names;

        break;
      }
      case Type::prefix_tree: {
        return value_.prefix_tree < rhs.value_.prefix_tree;

        break;
      }
      case Type::sets: {
        return value_.sets < rhs.value_.sets;

        break;
      }
      case Type::setter: {
        return value_.setter < rhs.value_.setter;

        break;
      }
      case Type::str: {
        return value_.str < rhs.value_.str;

        break;
      }
      case Type::strings: {
        return value_.strings < rhs.value_.strings;

        break;
      }
      case Type::type: {
        return value_.type < rhs.value_.type;

        break;
      }
      case Type::value: {
        return value_.value < rhs.value_.value;

        break;
      }
      case Type::value_to_name: {
        return value_.value_to_name < rhs.value_.value_to_name;

        break;
      }
      case Type::values: {
        return value_.values < rhs.value_.values;

        break;
      }
      case Type::id: {
        return value_.id < rhs.value_.id;

        break;
      }
      case Type::ids: {
        return value_.ids < rhs.value_.ids;

        break;
      }
      case Type::descriptor: {
        return value_.descriptor < rhs.value_.descriptor;

        break;
      }
      case Type::descriptors: {
        return value_.descriptors < rhs.value_.descriptors;

        break;
      }
      case Type::key: {
        return value_.key < rhs.value_.key;

        break;
      }
      case Type::keys: {
        return value_.keys < rhs.value_.keys;

        break;
      }
      case Type::annotation: {
        return value_.annotation < rhs.value_.annotation;

        break;
      }
      case Type::annotations: {
        return value_.annotations < rhs.value_.annotations;

        break;
      }
      case Type::member: {
        return value_.member < rhs.value_.member;

        break;
      }
      case Type::members: {
        return value_.members < rhs.value_.members;

        break;
      }
      default: return false;
    }
    return false;
  }

  template<typename... T>
  void set_get(T&&... t) {
    __clear();
    type_ = Type::get;
    new (&value_.get) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_getter(T&&... t) {
    __clear();
    type_ = Type::getter;
    new (&value_.getter) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_lists(T&&... t) {
    __clear();
    type_ = Type::lists;
    new (&value_.lists) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_maps(T&&... t) {
    __clear();
    type_ = Type::maps;
    new (&value_.maps) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_name(T&&... t) {
    __clear();
    type_ = Type::name;
    new (&value_.name) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_name_to_value(T&&... t) {
    __clear();
    type_ = Type::name_to_value;
    new (&value_.name_to_value) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_names(T&&... t) {
    __clear();
    type_ = Type::names;
    new (&value_.names) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_prefix_tree(T&&... t) {
    __clear();
    type_ = Type::prefix_tree;
    new (&value_.prefix_tree) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_sets(T&&... t) {
    __clear();
    type_ = Type::sets;
    new (&value_.sets) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_setter(T&&... t) {
    __clear();
    type_ = Type::setter;
    new (&value_.setter) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_str(T&&... t) {
    __clear();
    type_ = Type::str;
    new (&value_.str) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_strings(T&&... t) {
    __clear();
    type_ = Type::strings;
    new (&value_.strings) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_type(T&&... t) {
    __clear();
    type_ = Type::type;
    new (&value_.type) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_value(T&&... t) {
    __clear();
    type_ = Type::value;
    new (&value_.value) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_value_to_name(T&&... t) {
    __clear();
    type_ = Type::value_to_name;
    new (&value_.value_to_name) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_values(T&&... t) {
    __clear();
    type_ = Type::values;
    new (&value_.values) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_id(T&&... t) {
    __clear();
    type_ = Type::id;
    new (&value_.id) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ids(T&&... t) {
    __clear();
    type_ = Type::ids;
    new (&value_.ids) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_descriptor(T&&... t) {
    __clear();
    type_ = Type::descriptor;
    new (&value_.descriptor) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_descriptors(T&&... t) {
    __clear();
    type_ = Type::descriptors;
    new (&value_.descriptors) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_key(T&&... t) {
    __clear();
    type_ = Type::key;
    new (&value_.key) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_keys(T&&... t) {
    __clear();
    type_ = Type::keys;
    new (&value_.keys) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_annotation(T&&... t) {
    __clear();
    type_ = Type::annotation;
    new (&value_.annotation) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_annotations(T&&... t) {
    __clear();
    type_ = Type::annotations;
    new (&value_.annotations) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_member(T&&... t) {
    __clear();
    type_ = Type::member;
    new (&value_.member) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_members(T&&... t) {
    __clear();
    type_ = Type::members;
    new (&value_.members) int32_t(std::forward<T>(t)...);
  }

  const int32_t& get_get() const {
    assert(type_ == Type::get);
    return value_.get;
  }

  const int32_t& get_getter() const {
    assert(type_ == Type::getter);
    return value_.getter;
  }

  const int32_t& get_lists() const {
    assert(type_ == Type::lists);
    return value_.lists;
  }

  const int32_t& get_maps() const {
    assert(type_ == Type::maps);
    return value_.maps;
  }

  const int32_t& get_name() const {
    assert(type_ == Type::name);
    return value_.name;
  }

  const int32_t& get_name_to_value() const {
    assert(type_ == Type::name_to_value);
    return value_.name_to_value;
  }

  const int32_t& get_names() const {
    assert(type_ == Type::names);
    return value_.names;
  }

  const int32_t& get_prefix_tree() const {
    assert(type_ == Type::prefix_tree);
    return value_.prefix_tree;
  }

  const int32_t& get_sets() const {
    assert(type_ == Type::sets);
    return value_.sets;
  }

  const int32_t& get_setter() const {
    assert(type_ == Type::setter);
    return value_.setter;
  }

  const int32_t& get_str() const {
    assert(type_ == Type::str);
    return value_.str;
  }

  const int32_t& get_strings() const {
    assert(type_ == Type::strings);
    return value_.strings;
  }

  const int32_t& get_type() const {
    assert(type_ == Type::type);
    return value_.type;
  }

  const int32_t& get_value() const {
    assert(type_ == Type::value);
    return value_.value;
  }

  const int32_t& get_value_to_name() const {
    assert(type_ == Type::value_to_name);
    return value_.value_to_name;
  }

  const int32_t& get_values() const {
    assert(type_ == Type::values);
    return value_.values;
  }

  const int32_t& get_id() const {
    assert(type_ == Type::id);
    return value_.id;
  }

  const int32_t& get_ids() const {
    assert(type_ == Type::ids);
    return value_.ids;
  }

  const int32_t& get_descriptor() const {
    assert(type_ == Type::descriptor);
    return value_.descriptor;
  }

  const int32_t& get_descriptors() const {
    assert(type_ == Type::descriptors);
    return value_.descriptors;
  }

  const int32_t& get_key() const {
    assert(type_ == Type::key);
    return value_.key;
  }

  const int32_t& get_keys() const {
    assert(type_ == Type::keys);
    return value_.keys;
  }

  const int32_t& get_annotation() const {
    assert(type_ == Type::annotation);
    return value_.annotation;
  }

  const int32_t& get_annotations() const {
    assert(type_ == Type::annotations);
    return value_.annotations;
  }

  const int32_t& get_member() const {
    assert(type_ == Type::member);
    return value_.member;
  }

  const int32_t& get_members() const {
    assert(type_ == Type::members);
    return value_.members;
  }

  int32_t& mutable_get() {
    assert(type_ == Type::get);
    return value_.get;
  }

  int32_t& mutable_getter() {
    assert(type_ == Type::getter);
    return value_.getter;
  }

  int32_t& mutable_lists() {
    assert(type_ == Type::lists);
    return value_.lists;
  }

  int32_t& mutable_maps() {
    assert(type_ == Type::maps);
    return value_.maps;
  }

  int32_t& mutable_name() {
    assert(type_ == Type::name);
    return value_.name;
  }

  int32_t& mutable_name_to_value() {
    assert(type_ == Type::name_to_value);
    return value_.name_to_value;
  }

  int32_t& mutable_names() {
    assert(type_ == Type::names);
    return value_.names;
  }

  int32_t& mutable_prefix_tree() {
    assert(type_ == Type::prefix_tree);
    return value_.prefix_tree;
  }

  int32_t& mutable_sets() {
    assert(type_ == Type::sets);
    return value_.sets;
  }

  int32_t& mutable_setter() {
    assert(type_ == Type::setter);
    return value_.setter;
  }

  int32_t& mutable_str() {
    assert(type_ == Type::str);
    return value_.str;
  }

  int32_t& mutable_strings() {
    assert(type_ == Type::strings);
    return value_.strings;
  }

  int32_t& mutable_type() {
    assert(type_ == Type::type);
    return value_.type;
  }

  int32_t& mutable_value() {
    assert(type_ == Type::value);
    return value_.value;
  }

  int32_t& mutable_value_to_name() {
    assert(type_ == Type::value_to_name);
    return value_.value_to_name;
  }

  int32_t& mutable_values() {
    assert(type_ == Type::values);
    return value_.values;
  }

  int32_t& mutable_id() {
    assert(type_ == Type::id);
    return value_.id;
  }

  int32_t& mutable_ids() {
    assert(type_ == Type::ids);
    return value_.ids;
  }

  int32_t& mutable_descriptor() {
    assert(type_ == Type::descriptor);
    return value_.descriptor;
  }

  int32_t& mutable_descriptors() {
    assert(type_ == Type::descriptors);
    return value_.descriptors;
  }

  int32_t& mutable_key() {
    assert(type_ == Type::key);
    return value_.key;
  }

  int32_t& mutable_keys() {
    assert(type_ == Type::keys);
    return value_.keys;
  }

  int32_t& mutable_annotation() {
    assert(type_ == Type::annotation);
    return value_.annotation;
  }

  int32_t& mutable_annotations() {
    assert(type_ == Type::annotations);
    return value_.annotations;
  }

  int32_t& mutable_member() {
    assert(type_ == Type::member);
    return value_.member;
  }

  int32_t& mutable_members() {
    assert(type_ == Type::members);
    return value_.members;
  }

  int32_t move_get() {
    assert(type_ == Type::get);
    return std::move(value_.get);
  }

  int32_t move_getter() {
    assert(type_ == Type::getter);
    return std::move(value_.getter);
  }

  int32_t move_lists() {
    assert(type_ == Type::lists);
    return std::move(value_.lists);
  }

  int32_t move_maps() {
    assert(type_ == Type::maps);
    return std::move(value_.maps);
  }

  int32_t move_name() {
    assert(type_ == Type::name);
    return std::move(value_.name);
  }

  int32_t move_name_to_value() {
    assert(type_ == Type::name_to_value);
    return std::move(value_.name_to_value);
  }

  int32_t move_names() {
    assert(type_ == Type::names);
    return std::move(value_.names);
  }

  int32_t move_prefix_tree() {
    assert(type_ == Type::prefix_tree);
    return std::move(value_.prefix_tree);
  }

  int32_t move_sets() {
    assert(type_ == Type::sets);
    return std::move(value_.sets);
  }

  int32_t move_setter() {
    assert(type_ == Type::setter);
    return std::move(value_.setter);
  }

  int32_t move_str() {
    assert(type_ == Type::str);
    return std::move(value_.str);
  }

  int32_t move_strings() {
    assert(type_ == Type::strings);
    return std::move(value_.strings);
  }

  int32_t move_type() {
    assert(type_ == Type::type);
    return std::move(value_.type);
  }

  int32_t move_value() {
    assert(type_ == Type::value);
    return std::move(value_.value);
  }

  int32_t move_value_to_name() {
    assert(type_ == Type::value_to_name);
    return std::move(value_.value_to_name);
  }

  int32_t move_values() {
    assert(type_ == Type::values);
    return std::move(value_.values);
  }

  int32_t move_id() {
    assert(type_ == Type::id);
    return std::move(value_.id);
  }

  int32_t move_ids() {
    assert(type_ == Type::ids);
    return std::move(value_.ids);
  }

  int32_t move_descriptor() {
    assert(type_ == Type::descriptor);
    return std::move(value_.descriptor);
  }

  int32_t move_descriptors() {
    assert(type_ == Type::descriptors);
    return std::move(value_.descriptors);
  }

  int32_t move_key() {
    assert(type_ == Type::key);
    return std::move(value_.key);
  }

  int32_t move_keys() {
    assert(type_ == Type::keys);
    return std::move(value_.keys);
  }

  int32_t move_annotation() {
    assert(type_ == Type::annotation);
    return std::move(value_.annotation);
  }

  int32_t move_annotations() {
    assert(type_ == Type::annotations);
    return std::move(value_.annotations);
  }

  int32_t move_member() {
    assert(type_ == Type::member);
    return std::move(value_.member);
  }

  int32_t move_members() {
    assert(type_ == Type::members);
    return std::move(value_.members);
  }

  Type getType() const { return type_; }

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;
 private:
  Type type_;
  storage_type value_;

};

void swap(struct_with_special_names &a, struct_with_special_names &b);

class struct_with_special_names : public apache::thrift::TStructType<struct_with_special_names> {
 public:

  static const uint64_t _reflection_id = 8634504681174503372U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  struct_with_special_names() : get(0), getter(0), lists(0), maps(0), name(0), name_to_value(0), names(0), prefix_tree(0), sets(0), setter(0), str(0), strings(0), type(0), value(0), value_to_name(0), values(0), id(0), ids(0), descriptor(0), descriptors(0), key(0), keys(0), annotation(0), annotations(0), member(0), members(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    get = arg.move();
    __isset.get = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    getter = arg.move();
    __isset.getter = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    lists = arg.move();
    __isset.lists = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    maps = arg.move();
    __isset.maps = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    name = arg.move();
    __isset.name = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    name_to_value = arg.move();
    __isset.name_to_value = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<7, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    names = arg.move();
    __isset.names = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<8, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    prefix_tree = arg.move();
    __isset.prefix_tree = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<9, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    sets = arg.move();
    __isset.sets = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<10, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    setter = arg.move();
    __isset.setter = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<11, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    str = arg.move();
    __isset.str = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<12, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    strings = arg.move();
    __isset.strings = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<13, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    type = arg.move();
    __isset.type = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<14, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<15, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value_to_name = arg.move();
    __isset.value_to_name = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<16, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    values = arg.move();
    __isset.values = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<17, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id = arg.move();
    __isset.id = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<18, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    ids = arg.move();
    __isset.ids = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<19, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    descriptor = arg.move();
    __isset.descriptor = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<20, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    descriptors = arg.move();
    __isset.descriptors = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<21, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<22, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    keys = arg.move();
    __isset.keys = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<23, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    annotation = arg.move();
    __isset.annotation = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<24, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    annotations = arg.move();
    __isset.annotations = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<25, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    member = arg.move();
    __isset.member = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit struct_with_special_names(
    ::apache::thrift::detail::argument_wrapper<26, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    struct_with_special_names(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    members = arg.move();
    __isset.members = true;
  }

  struct_with_special_names(const struct_with_special_names&) = default;
  struct_with_special_names& operator=(const struct_with_special_names& src)= default;
  struct_with_special_names(struct_with_special_names&&) = default;
  struct_with_special_names& operator=(struct_with_special_names&&) = default;

  void __clear();

  virtual ~struct_with_special_names() throw() {}

  int32_t get;
  int32_t getter;
  int32_t lists;
  int32_t maps;
  int32_t name;
  int32_t name_to_value;
  int32_t names;
  int32_t prefix_tree;
  int32_t sets;
  int32_t setter;
  int32_t str;
  int32_t strings;
  int32_t type;
  int32_t value;
  int32_t value_to_name;
  int32_t values;
  int32_t id;
  int32_t ids;
  int32_t descriptor;
  int32_t descriptors;
  int32_t key;
  int32_t keys;
  int32_t annotation;
  int32_t annotations;
  int32_t member;
  int32_t members;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      get = false;
      getter = false;
      lists = false;
      maps = false;
      name = false;
      name_to_value = false;
      names = false;
      prefix_tree = false;
      sets = false;
      setter = false;
      str = false;
      strings = false;
      type = false;
      value = false;
      value_to_name = false;
      values = false;
      id = false;
      ids = false;
      descriptor = false;
      descriptors = false;
      key = false;
      keys = false;
      annotation = false;
      annotations = false;
      member = false;
      members = false;
    }
    bool get;
    bool getter;
    bool lists;
    bool maps;
    bool name;
    bool name_to_value;
    bool names;
    bool prefix_tree;
    bool sets;
    bool setter;
    bool str;
    bool strings;
    bool type;
    bool value;
    bool value_to_name;
    bool values;
    bool id;
    bool ids;
    bool descriptor;
    bool descriptors;
    bool key;
    bool keys;
    bool annotation;
    bool annotations;
    bool member;
    bool members;
  } __isset;

  bool operator == (const struct_with_special_names &) const;
  bool operator != (const struct_with_special_names& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const struct_with_special_names & ) const;

  void readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  void readFromJson(const char* jsonText, const folly::json::serialization_opts& opts = folly::json::serialization_opts());
  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class struct_with_special_names;
void merge(const struct_with_special_names& from, struct_with_special_names& to);
void merge(struct_with_special_names&& from, struct_with_special_names& to);
}} // namespace


/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/module_fatal.h"

#include <fatal/type/enum.h>
#include <fatal/type/variant_traits.h>

#include <type_traits>

namespace test_cpp2 { namespace cpp_reflection {

namespace thrift_fatal_impl_detail {

struct union1_Type_enum_traits {
  using type = ::test_cpp2::cpp_reflection::union1::Type;
  using name = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::Type;

  struct Type__struct_unique_strings_list {
    using ui = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ui;
    using ud = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ud;
    using us = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::us;
    using ue = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ue;
  };

  struct Type__struct_enum_members_ui {
    using name = Type__struct_unique_strings_list::ui;
    using value = std::integral_constant<type, type::ui>;
  };

  struct Type__struct_enum_members_ud {
    using name = Type__struct_unique_strings_list::ud;
    using value = std::integral_constant<type, type::ud>;
  };

  struct Type__struct_enum_members_us {
    using name = Type__struct_unique_strings_list::us;
    using value = std::integral_constant<type, type::us>;
  };

  struct Type__struct_enum_members_ue {
    using name = Type__struct_unique_strings_list::ue;
    using value = std::integral_constant<type, type::ue>;
  };

  struct Type__struct_enum_members {
    using ui = Type__struct_enum_members_ui;
    using ud = Type__struct_enum_members_ud;
    using us = Type__struct_enum_members_us;
    using ue = Type__struct_enum_members_ue;
  };

  using member = Type__struct_enum_members;

  using fields = ::fatal::list<
      member::ui,
      member::ud,
      member::us,
      member::ue
  >;

  class annotations {
    struct annotations__unique_annotations_keys {};

    struct annotations__unique_annotations_values {};

    public:
    using keys = annotations__unique_annotations_keys;
    using values = annotations__unique_annotations_values;
    using map = ::fatal::list<
    >;
  };

  static char const *to_string(type e, char const *fallback) {
    switch (e) {
      case type::ui: return "ui";
      case type::ud: return "ud";
      case type::us: return "us";
      case type::ue: return "ue";
      default: return fallback;
    }
  }
};

} // thrift_fatal_impl_detail

FATAL_REGISTER_ENUM_TRAITS(
  ::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union1_Type_enum_traits,
  ::apache::thrift::detail::type_common_metadata_impl<
    module_tags::module,
    ::apache::thrift::reflected_annotations<::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union1_Type_enum_traits::annotations>,
    static_cast<::apache::thrift::legacy_type_id_t>(0ull)
  >
);

namespace thrift_fatal_impl_detail {

class union1_variant_traits {
  struct union1__struct_unique_identifiers_list {
    using ui = std::integral_constant<::test_cpp2::cpp_reflection::union1::Type, ::test_cpp2::cpp_reflection::union1::Type::ui>;
    using ud = std::integral_constant<::test_cpp2::cpp_reflection::union1::Type, ::test_cpp2::cpp_reflection::union1::Type::ud>;
    using us = std::integral_constant<::test_cpp2::cpp_reflection::union1::Type, ::test_cpp2::cpp_reflection::union1::Type::us>;
    using ue = std::integral_constant<::test_cpp2::cpp_reflection::union1::Type, ::test_cpp2::cpp_reflection::union1::Type::ue>;
  };

  struct union1__struct_unique_getters_list {
    struct ui {
      auto operator ()(union1 const &variant) const
        -> decltype(std::declval<union1 const &>().get_ui())
      {
        return variant.get_ui();
      }

      auto operator ()(union1 &variant) const
        -> decltype(std::declval<union1 &>().mutable_ui())
      {
        return variant.mutable_ui();
      }

      auto operator ()(union1 &&variant) const
        -> decltype(std::declval<union1 &&>().move_ui())
      {
        return std::move(variant).move_ui();
      }
    };

    struct ud {
      auto operator ()(union1 const &variant) const
        -> decltype(std::declval<union1 const &>().get_ud())
      {
        return variant.get_ud();
      }

      auto operator ()(union1 &variant) const
        -> decltype(std::declval<union1 &>().mutable_ud())
      {
        return variant.mutable_ud();
      }

      auto operator ()(union1 &&variant) const
        -> decltype(std::declval<union1 &&>().move_ud())
      {
        return std::move(variant).move_ud();
      }
    };

    struct us {
      auto operator ()(union1 const &variant) const
        -> decltype(std::declval<union1 const &>().get_us())
      {
        return variant.get_us();
      }

      auto operator ()(union1 &variant) const
        -> decltype(std::declval<union1 &>().mutable_us())
      {
        return variant.mutable_us();
      }

      auto operator ()(union1 &&variant) const
        -> decltype(std::declval<union1 &&>().move_us())
      {
        return std::move(variant).move_us();
      }
    };

    struct ue {
      auto operator ()(union1 const &variant) const
        -> decltype(std::declval<union1 const &>().get_ue())
      {
        return variant.get_ue();
      }

      auto operator ()(union1 &variant) const
        -> decltype(std::declval<union1 &>().mutable_ue())
      {
        return variant.mutable_ue();
      }

      auto operator ()(union1 &&variant) const
        -> decltype(std::declval<union1 &&>().move_ue())
      {
        return std::move(variant).move_ue();
      }
    };
  };

  struct union1__struct_unique_setters_list {
    struct ui {
      template <typename... Args>
      auto operator ()(union1 &variant, Args &&...args) const
        -> decltype(
          std::declval<union1 &>().set_ui(std::forward<Args>(args)...)
        )
      {
        return variant.set_ui(std::forward<Args>(args)...);
      }
    };

    struct ud {
      template <typename... Args>
      auto operator ()(union1 &variant, Args &&...args) const
        -> decltype(
          std::declval<union1 &>().set_ud(std::forward<Args>(args)...)
        )
      {
        return variant.set_ud(std::forward<Args>(args)...);
      }
    };

    struct us {
      template <typename... Args>
      auto operator ()(union1 &variant, Args &&...args) const
        -> decltype(
          std::declval<union1 &>().set_us(std::forward<Args>(args)...)
        )
      {
        return variant.set_us(std::forward<Args>(args)...);
      }
    };

    struct ue {
      template <typename... Args>
      auto operator ()(union1 &variant, Args &&...args) const
        -> decltype(
          std::declval<union1 &>().set_ue(std::forward<Args>(args)...)
        )
      {
        return variant.set_ue(std::forward<Args>(args)...);
      }
    };
  };

  public:
  using type = ::test_cpp2::cpp_reflection::union1;
  using name = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::union1;
  using id = type::Type;
  using ids = union1__struct_unique_identifiers_list;
  using descriptors = ::fatal::list<
    ::fatal::variant_member_descriptor<
      int32_t,
      union1__struct_unique_identifiers_list::ui,
      union1__struct_unique_getters_list::ui,
      union1__struct_unique_setters_list::ui,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ui,
        1,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      double,
      union1__struct_unique_identifiers_list::ud,
      union1__struct_unique_getters_list::ud,
      union1__struct_unique_setters_list::ud,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ud,
        2,
        ::apache::thrift::type_class::floating_point
      >
    >,
    ::fatal::variant_member_descriptor<
      std::string,
      union1__struct_unique_identifiers_list::us,
      union1__struct_unique_getters_list::us,
      union1__struct_unique_setters_list::us,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::us,
        3,
        ::apache::thrift::type_class::string
      >
    >,
    ::fatal::variant_member_descriptor<
       ::test_cpp2::cpp_reflection::enum1,
      union1__struct_unique_identifiers_list::ue,
      union1__struct_unique_getters_list::ue,
      union1__struct_unique_setters_list::ue,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ue,
        4,
        ::apache::thrift::type_class::enumeration
      >
    >
  >;

  class annotations {
    struct annotations__unique_annotations_keys {};

    struct annotations__unique_annotations_values {};

    public:
    using keys = annotations__unique_annotations_keys;
    using values = annotations__unique_annotations_values;
    using map = ::fatal::list<
    >;
  };

  static id get_id(type const &variant) {
    return variant.getType();
  }

  static bool empty(type const &variant) {
    return variant.getType() == id::__EMPTY__;
  }

  static void clear(type &variant) {
    return variant.__clear();
  }
};

} // thrift_fatal_impl_detail
namespace thrift_fatal_impl_detail {

struct union2_Type_enum_traits {
  using type = ::test_cpp2::cpp_reflection::union2::Type;
  using name = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::Type;

  struct Type__struct_unique_strings_list {
    using ui_2 = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ui_2;
    using ud_2 = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ud_2;
    using us_2 = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::us_2;
    using ue_2 = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ue_2;
  };

  struct Type__struct_enum_members_ui_2 {
    using name = Type__struct_unique_strings_list::ui_2;
    using value = std::integral_constant<type, type::ui_2>;
  };

  struct Type__struct_enum_members_ud_2 {
    using name = Type__struct_unique_strings_list::ud_2;
    using value = std::integral_constant<type, type::ud_2>;
  };

  struct Type__struct_enum_members_us_2 {
    using name = Type__struct_unique_strings_list::us_2;
    using value = std::integral_constant<type, type::us_2>;
  };

  struct Type__struct_enum_members_ue_2 {
    using name = Type__struct_unique_strings_list::ue_2;
    using value = std::integral_constant<type, type::ue_2>;
  };

  struct Type__struct_enum_members {
    using ui_2 = Type__struct_enum_members_ui_2;
    using ud_2 = Type__struct_enum_members_ud_2;
    using us_2 = Type__struct_enum_members_us_2;
    using ue_2 = Type__struct_enum_members_ue_2;
  };

  using member = Type__struct_enum_members;

  using fields = ::fatal::list<
      member::ui_2,
      member::ud_2,
      member::us_2,
      member::ue_2
  >;

  class annotations {
    struct annotations__unique_annotations_keys {};

    struct annotations__unique_annotations_values {};

    public:
    using keys = annotations__unique_annotations_keys;
    using values = annotations__unique_annotations_values;
    using map = ::fatal::list<
    >;
  };

  static char const *to_string(type e, char const *fallback) {
    switch (e) {
      case type::ui_2: return "ui_2";
      case type::ud_2: return "ud_2";
      case type::us_2: return "us_2";
      case type::ue_2: return "ue_2";
      default: return fallback;
    }
  }
};

} // thrift_fatal_impl_detail

FATAL_REGISTER_ENUM_TRAITS(
  ::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union2_Type_enum_traits,
  ::apache::thrift::detail::type_common_metadata_impl<
    module_tags::module,
    ::apache::thrift::reflected_annotations<::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union2_Type_enum_traits::annotations>,
    static_cast<::apache::thrift::legacy_type_id_t>(0ull)
  >
);

namespace thrift_fatal_impl_detail {

class union2_variant_traits {
  struct union2__struct_unique_identifiers_list {
    using ui_2 = std::integral_constant<::test_cpp2::cpp_reflection::union2::Type, ::test_cpp2::cpp_reflection::union2::Type::ui_2>;
    using ud_2 = std::integral_constant<::test_cpp2::cpp_reflection::union2::Type, ::test_cpp2::cpp_reflection::union2::Type::ud_2>;
    using us_2 = std::integral_constant<::test_cpp2::cpp_reflection::union2::Type, ::test_cpp2::cpp_reflection::union2::Type::us_2>;
    using ue_2 = std::integral_constant<::test_cpp2::cpp_reflection::union2::Type, ::test_cpp2::cpp_reflection::union2::Type::ue_2>;
  };

  struct union2__struct_unique_getters_list {
    struct ui_2 {
      auto operator ()(union2 const &variant) const
        -> decltype(std::declval<union2 const &>().get_ui_2())
      {
        return variant.get_ui_2();
      }

      auto operator ()(union2 &variant) const
        -> decltype(std::declval<union2 &>().mutable_ui_2())
      {
        return variant.mutable_ui_2();
      }

      auto operator ()(union2 &&variant) const
        -> decltype(std::declval<union2 &&>().move_ui_2())
      {
        return std::move(variant).move_ui_2();
      }
    };

    struct ud_2 {
      auto operator ()(union2 const &variant) const
        -> decltype(std::declval<union2 const &>().get_ud_2())
      {
        return variant.get_ud_2();
      }

      auto operator ()(union2 &variant) const
        -> decltype(std::declval<union2 &>().mutable_ud_2())
      {
        return variant.mutable_ud_2();
      }

      auto operator ()(union2 &&variant) const
        -> decltype(std::declval<union2 &&>().move_ud_2())
      {
        return std::move(variant).move_ud_2();
      }
    };

    struct us_2 {
      auto operator ()(union2 const &variant) const
        -> decltype(std::declval<union2 const &>().get_us_2())
      {
        return variant.get_us_2();
      }

      auto operator ()(union2 &variant) const
        -> decltype(std::declval<union2 &>().mutable_us_2())
      {
        return variant.mutable_us_2();
      }

      auto operator ()(union2 &&variant) const
        -> decltype(std::declval<union2 &&>().move_us_2())
      {
        return std::move(variant).move_us_2();
      }
    };

    struct ue_2 {
      auto operator ()(union2 const &variant) const
        -> decltype(std::declval<union2 const &>().get_ue_2())
      {
        return variant.get_ue_2();
      }

      auto operator ()(union2 &variant) const
        -> decltype(std::declval<union2 &>().mutable_ue_2())
      {
        return variant.mutable_ue_2();
      }

      auto operator ()(union2 &&variant) const
        -> decltype(std::declval<union2 &&>().move_ue_2())
      {
        return std::move(variant).move_ue_2();
      }
    };
  };

  struct union2__struct_unique_setters_list {
    struct ui_2 {
      template <typename... Args>
      auto operator ()(union2 &variant, Args &&...args) const
        -> decltype(
          std::declval<union2 &>().set_ui_2(std::forward<Args>(args)...)
        )
      {
        return variant.set_ui_2(std::forward<Args>(args)...);
      }
    };

    struct ud_2 {
      template <typename... Args>
      auto operator ()(union2 &variant, Args &&...args) const
        -> decltype(
          std::declval<union2 &>().set_ud_2(std::forward<Args>(args)...)
        )
      {
        return variant.set_ud_2(std::forward<Args>(args)...);
      }
    };

    struct us_2 {
      template <typename... Args>
      auto operator ()(union2 &variant, Args &&...args) const
        -> decltype(
          std::declval<union2 &>().set_us_2(std::forward<Args>(args)...)
        )
      {
        return variant.set_us_2(std::forward<Args>(args)...);
      }
    };

    struct ue_2 {
      template <typename... Args>
      auto operator ()(union2 &variant, Args &&...args) const
        -> decltype(
          std::declval<union2 &>().set_ue_2(std::forward<Args>(args)...)
        )
      {
        return variant.set_ue_2(std::forward<Args>(args)...);
      }
    };
  };

  public:
  using type = ::test_cpp2::cpp_reflection::union2;
  using name = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::union2;
  using id = type::Type;
  using ids = union2__struct_unique_identifiers_list;
  using descriptors = ::fatal::list<
    ::fatal::variant_member_descriptor<
      int32_t,
      union2__struct_unique_identifiers_list::ui_2,
      union2__struct_unique_getters_list::ui_2,
      union2__struct_unique_setters_list::ui_2,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ui_2,
        1,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      double,
      union2__struct_unique_identifiers_list::ud_2,
      union2__struct_unique_getters_list::ud_2,
      union2__struct_unique_setters_list::ud_2,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ud_2,
        2,
        ::apache::thrift::type_class::floating_point
      >
    >,
    ::fatal::variant_member_descriptor<
      std::string,
      union2__struct_unique_identifiers_list::us_2,
      union2__struct_unique_getters_list::us_2,
      union2__struct_unique_setters_list::us_2,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::us_2,
        3,
        ::apache::thrift::type_class::string
      >
    >,
    ::fatal::variant_member_descriptor<
       ::test_cpp2::cpp_reflection::enum1,
      union2__struct_unique_identifiers_list::ue_2,
      union2__struct_unique_getters_list::ue_2,
      union2__struct_unique_setters_list::ue_2,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ue_2,
        4,
        ::apache::thrift::type_class::enumeration
      >
    >
  >;

  class annotations {
    struct annotations__unique_annotations_keys {};

    struct annotations__unique_annotations_values {};

    public:
    using keys = annotations__unique_annotations_keys;
    using values = annotations__unique_annotations_values;
    using map = ::fatal::list<
    >;
  };

  static id get_id(type const &variant) {
    return variant.getType();
  }

  static bool empty(type const &variant) {
    return variant.getType() == id::__EMPTY__;
  }

  static void clear(type &variant) {
    return variant.__clear();
  }
};

} // thrift_fatal_impl_detail
namespace thrift_fatal_impl_detail {

struct union3_Type_enum_traits {
  using type = ::test_cpp2::cpp_reflection::union3::Type;
  using name = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::Type;

  struct Type__struct_unique_strings_list {
    using ui_3 = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ui_3;
    using ud_3 = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ud_3;
    using us_3 = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::us_3;
    using ue_3 = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ue_3;
  };

  struct Type__struct_enum_members_ui_3 {
    using name = Type__struct_unique_strings_list::ui_3;
    using value = std::integral_constant<type, type::ui_3>;
  };

  struct Type__struct_enum_members_ud_3 {
    using name = Type__struct_unique_strings_list::ud_3;
    using value = std::integral_constant<type, type::ud_3>;
  };

  struct Type__struct_enum_members_us_3 {
    using name = Type__struct_unique_strings_list::us_3;
    using value = std::integral_constant<type, type::us_3>;
  };

  struct Type__struct_enum_members_ue_3 {
    using name = Type__struct_unique_strings_list::ue_3;
    using value = std::integral_constant<type, type::ue_3>;
  };

  struct Type__struct_enum_members {
    using ui_3 = Type__struct_enum_members_ui_3;
    using ud_3 = Type__struct_enum_members_ud_3;
    using us_3 = Type__struct_enum_members_us_3;
    using ue_3 = Type__struct_enum_members_ue_3;
  };

  using member = Type__struct_enum_members;

  using fields = ::fatal::list<
      member::ui_3,
      member::ud_3,
      member::us_3,
      member::ue_3
  >;

  class annotations {
    struct annotations__unique_annotations_keys {};

    struct annotations__unique_annotations_values {};

    public:
    using keys = annotations__unique_annotations_keys;
    using values = annotations__unique_annotations_values;
    using map = ::fatal::list<
    >;
  };

  static char const *to_string(type e, char const *fallback) {
    switch (e) {
      case type::ui_3: return "ui_3";
      case type::ud_3: return "ud_3";
      case type::us_3: return "us_3";
      case type::ue_3: return "ue_3";
      default: return fallback;
    }
  }
};

} // thrift_fatal_impl_detail

FATAL_REGISTER_ENUM_TRAITS(
  ::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union3_Type_enum_traits,
  ::apache::thrift::detail::type_common_metadata_impl<
    module_tags::module,
    ::apache::thrift::reflected_annotations<::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union3_Type_enum_traits::annotations>,
    static_cast<::apache::thrift::legacy_type_id_t>(0ull)
  >
);

namespace thrift_fatal_impl_detail {

class union3_variant_traits {
  struct union3__struct_unique_identifiers_list {
    using ui_3 = std::integral_constant<::test_cpp2::cpp_reflection::union3::Type, ::test_cpp2::cpp_reflection::union3::Type::ui_3>;
    using ud_3 = std::integral_constant<::test_cpp2::cpp_reflection::union3::Type, ::test_cpp2::cpp_reflection::union3::Type::ud_3>;
    using us_3 = std::integral_constant<::test_cpp2::cpp_reflection::union3::Type, ::test_cpp2::cpp_reflection::union3::Type::us_3>;
    using ue_3 = std::integral_constant<::test_cpp2::cpp_reflection::union3::Type, ::test_cpp2::cpp_reflection::union3::Type::ue_3>;
  };

  struct union3__struct_unique_getters_list {
    struct ui_3 {
      auto operator ()(union3 const &variant) const
        -> decltype(std::declval<union3 const &>().get_ui_3())
      {
        return variant.get_ui_3();
      }

      auto operator ()(union3 &variant) const
        -> decltype(std::declval<union3 &>().mutable_ui_3())
      {
        return variant.mutable_ui_3();
      }

      auto operator ()(union3 &&variant) const
        -> decltype(std::declval<union3 &&>().move_ui_3())
      {
        return std::move(variant).move_ui_3();
      }
    };

    struct ud_3 {
      auto operator ()(union3 const &variant) const
        -> decltype(std::declval<union3 const &>().get_ud_3())
      {
        return variant.get_ud_3();
      }

      auto operator ()(union3 &variant) const
        -> decltype(std::declval<union3 &>().mutable_ud_3())
      {
        return variant.mutable_ud_3();
      }

      auto operator ()(union3 &&variant) const
        -> decltype(std::declval<union3 &&>().move_ud_3())
      {
        return std::move(variant).move_ud_3();
      }
    };

    struct us_3 {
      auto operator ()(union3 const &variant) const
        -> decltype(std::declval<union3 const &>().get_us_3())
      {
        return variant.get_us_3();
      }

      auto operator ()(union3 &variant) const
        -> decltype(std::declval<union3 &>().mutable_us_3())
      {
        return variant.mutable_us_3();
      }

      auto operator ()(union3 &&variant) const
        -> decltype(std::declval<union3 &&>().move_us_3())
      {
        return std::move(variant).move_us_3();
      }
    };

    struct ue_3 {
      auto operator ()(union3 const &variant) const
        -> decltype(std::declval<union3 const &>().get_ue_3())
      {
        return variant.get_ue_3();
      }

      auto operator ()(union3 &variant) const
        -> decltype(std::declval<union3 &>().mutable_ue_3())
      {
        return variant.mutable_ue_3();
      }

      auto operator ()(union3 &&variant) const
        -> decltype(std::declval<union3 &&>().move_ue_3())
      {
        return std::move(variant).move_ue_3();
      }
    };
  };

  struct union3__struct_unique_setters_list {
    struct ui_3 {
      template <typename... Args>
      auto operator ()(union3 &variant, Args &&...args) const
        -> decltype(
          std::declval<union3 &>().set_ui_3(std::forward<Args>(args)...)
        )
      {
        return variant.set_ui_3(std::forward<Args>(args)...);
      }
    };

    struct ud_3 {
      template <typename... Args>
      auto operator ()(union3 &variant, Args &&...args) const
        -> decltype(
          std::declval<union3 &>().set_ud_3(std::forward<Args>(args)...)
        )
      {
        return variant.set_ud_3(std::forward<Args>(args)...);
      }
    };

    struct us_3 {
      template <typename... Args>
      auto operator ()(union3 &variant, Args &&...args) const
        -> decltype(
          std::declval<union3 &>().set_us_3(std::forward<Args>(args)...)
        )
      {
        return variant.set_us_3(std::forward<Args>(args)...);
      }
    };

    struct ue_3 {
      template <typename... Args>
      auto operator ()(union3 &variant, Args &&...args) const
        -> decltype(
          std::declval<union3 &>().set_ue_3(std::forward<Args>(args)...)
        )
      {
        return variant.set_ue_3(std::forward<Args>(args)...);
      }
    };
  };

  public:
  using type = ::test_cpp2::cpp_reflection::union3;
  using name = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::union3;
  using id = type::Type;
  using ids = union3__struct_unique_identifiers_list;
  using descriptors = ::fatal::list<
    ::fatal::variant_member_descriptor<
      int32_t,
      union3__struct_unique_identifiers_list::ui_3,
      union3__struct_unique_getters_list::ui_3,
      union3__struct_unique_setters_list::ui_3,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ui_3,
        1,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      double,
      union3__struct_unique_identifiers_list::ud_3,
      union3__struct_unique_getters_list::ud_3,
      union3__struct_unique_setters_list::ud_3,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ud_3,
        2,
        ::apache::thrift::type_class::floating_point
      >
    >,
    ::fatal::variant_member_descriptor<
      std::string,
      union3__struct_unique_identifiers_list::us_3,
      union3__struct_unique_getters_list::us_3,
      union3__struct_unique_setters_list::us_3,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::us_3,
        3,
        ::apache::thrift::type_class::string
      >
    >,
    ::fatal::variant_member_descriptor<
       ::test_cpp2::cpp_reflection::enum1,
      union3__struct_unique_identifiers_list::ue_3,
      union3__struct_unique_getters_list::ue_3,
      union3__struct_unique_setters_list::ue_3,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ue_3,
        4,
        ::apache::thrift::type_class::enumeration
      >
    >
  >;

  class annotations {
    struct annotations__unique_annotations_keys {};

    struct annotations__unique_annotations_values {};

    public:
    using keys = annotations__unique_annotations_keys;
    using values = annotations__unique_annotations_values;
    using map = ::fatal::list<
    >;
  };

  static id get_id(type const &variant) {
    return variant.getType();
  }

  static bool empty(type const &variant) {
    return variant.getType() == id::__EMPTY__;
  }

  static void clear(type &variant) {
    return variant.__clear();
  }
};

} // thrift_fatal_impl_detail
namespace thrift_fatal_impl_detail {

struct unionA_Type_enum_traits {
  using type = ::test_cpp2::cpp_reflection::unionA::Type;
  using name = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::Type;

  struct Type__struct_unique_strings_list {
    using i = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::i;
    using d = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::d;
    using s = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::s;
    using e = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::e;
    using a = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::a;
  };

  struct Type__struct_enum_members_i {
    using name = Type__struct_unique_strings_list::i;
    using value = std::integral_constant<type, type::i>;
  };

  struct Type__struct_enum_members_d {
    using name = Type__struct_unique_strings_list::d;
    using value = std::integral_constant<type, type::d>;
  };

  struct Type__struct_enum_members_s {
    using name = Type__struct_unique_strings_list::s;
    using value = std::integral_constant<type, type::s>;
  };

  struct Type__struct_enum_members_e {
    using name = Type__struct_unique_strings_list::e;
    using value = std::integral_constant<type, type::e>;
  };

  struct Type__struct_enum_members_a {
    using name = Type__struct_unique_strings_list::a;
    using value = std::integral_constant<type, type::a>;
  };

  struct Type__struct_enum_members {
    using i = Type__struct_enum_members_i;
    using d = Type__struct_enum_members_d;
    using s = Type__struct_enum_members_s;
    using e = Type__struct_enum_members_e;
    using a = Type__struct_enum_members_a;
  };

  using member = Type__struct_enum_members;

  using fields = ::fatal::list<
      member::i,
      member::d,
      member::s,
      member::e,
      member::a
  >;

  class annotations {
    struct annotations__unique_annotations_keys {};

    struct annotations__unique_annotations_values {};

    public:
    using keys = annotations__unique_annotations_keys;
    using values = annotations__unique_annotations_values;
    using map = ::fatal::list<
    >;
  };

  static char const *to_string(type e, char const *fallback) {
    switch (e) {
      case type::i: return "i";
      case type::d: return "d";
      case type::s: return "s";
      case type::e: return "e";
      case type::a: return "a";
      default: return fallback;
    }
  }
};

} // thrift_fatal_impl_detail

FATAL_REGISTER_ENUM_TRAITS(
  ::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::unionA_Type_enum_traits,
  ::apache::thrift::detail::type_common_metadata_impl<
    module_tags::module,
    ::apache::thrift::reflected_annotations<::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::unionA_Type_enum_traits::annotations>,
    static_cast<::apache::thrift::legacy_type_id_t>(0ull)
  >
);

namespace thrift_fatal_impl_detail {

class unionA_variant_traits {
  struct unionA__struct_unique_identifiers_list {
    using i = std::integral_constant<::test_cpp2::cpp_reflection::unionA::Type, ::test_cpp2::cpp_reflection::unionA::Type::i>;
    using d = std::integral_constant<::test_cpp2::cpp_reflection::unionA::Type, ::test_cpp2::cpp_reflection::unionA::Type::d>;
    using s = std::integral_constant<::test_cpp2::cpp_reflection::unionA::Type, ::test_cpp2::cpp_reflection::unionA::Type::s>;
    using e = std::integral_constant<::test_cpp2::cpp_reflection::unionA::Type, ::test_cpp2::cpp_reflection::unionA::Type::e>;
    using a = std::integral_constant<::test_cpp2::cpp_reflection::unionA::Type, ::test_cpp2::cpp_reflection::unionA::Type::a>;
  };

  struct unionA__struct_unique_getters_list {
    struct i {
      auto operator ()(unionA const &variant) const
        -> decltype(std::declval<unionA const &>().get_i())
      {
        return variant.get_i();
      }

      auto operator ()(unionA &variant) const
        -> decltype(std::declval<unionA &>().mutable_i())
      {
        return variant.mutable_i();
      }

      auto operator ()(unionA &&variant) const
        -> decltype(std::declval<unionA &&>().move_i())
      {
        return std::move(variant).move_i();
      }
    };

    struct d {
      auto operator ()(unionA const &variant) const
        -> decltype(std::declval<unionA const &>().get_d())
      {
        return variant.get_d();
      }

      auto operator ()(unionA &variant) const
        -> decltype(std::declval<unionA &>().mutable_d())
      {
        return variant.mutable_d();
      }

      auto operator ()(unionA &&variant) const
        -> decltype(std::declval<unionA &&>().move_d())
      {
        return std::move(variant).move_d();
      }
    };

    struct s {
      auto operator ()(unionA const &variant) const
        -> decltype(std::declval<unionA const &>().get_s())
      {
        return variant.get_s();
      }

      auto operator ()(unionA &variant) const
        -> decltype(std::declval<unionA &>().mutable_s())
      {
        return variant.mutable_s();
      }

      auto operator ()(unionA &&variant) const
        -> decltype(std::declval<unionA &&>().move_s())
      {
        return std::move(variant).move_s();
      }
    };

    struct e {
      auto operator ()(unionA const &variant) const
        -> decltype(std::declval<unionA const &>().get_e())
      {
        return variant.get_e();
      }

      auto operator ()(unionA &variant) const
        -> decltype(std::declval<unionA &>().mutable_e())
      {
        return variant.mutable_e();
      }

      auto operator ()(unionA &&variant) const
        -> decltype(std::declval<unionA &&>().move_e())
      {
        return std::move(variant).move_e();
      }
    };

    struct a {
      auto operator ()(unionA const &variant) const
        -> decltype(std::declval<unionA const &>().get_a())
      {
        return variant.get_a();
      }

      auto operator ()(unionA &variant) const
        -> decltype(std::declval<unionA &>().mutable_a())
      {
        return variant.mutable_a();
      }

      auto operator ()(unionA &&variant) const
        -> decltype(std::declval<unionA &&>().move_a())
      {
        return std::move(variant).move_a();
      }
    };
  };

  struct unionA__struct_unique_setters_list {
    struct i {
      template <typename... Args>
      auto operator ()(unionA &variant, Args &&...args) const
        -> decltype(
          std::declval<unionA &>().set_i(std::forward<Args>(args)...)
        )
      {
        return variant.set_i(std::forward<Args>(args)...);
      }
    };

    struct d {
      template <typename... Args>
      auto operator ()(unionA &variant, Args &&...args) const
        -> decltype(
          std::declval<unionA &>().set_d(std::forward<Args>(args)...)
        )
      {
        return variant.set_d(std::forward<Args>(args)...);
      }
    };

    struct s {
      template <typename... Args>
      auto operator ()(unionA &variant, Args &&...args) const
        -> decltype(
          std::declval<unionA &>().set_s(std::forward<Args>(args)...)
        )
      {
        return variant.set_s(std::forward<Args>(args)...);
      }
    };

    struct e {
      template <typename... Args>
      auto operator ()(unionA &variant, Args &&...args) const
        -> decltype(
          std::declval<unionA &>().set_e(std::forward<Args>(args)...)
        )
      {
        return variant.set_e(std::forward<Args>(args)...);
      }
    };

    struct a {
      template <typename... Args>
      auto operator ()(unionA &variant, Args &&...args) const
        -> decltype(
          std::declval<unionA &>().set_a(std::forward<Args>(args)...)
        )
      {
        return variant.set_a(std::forward<Args>(args)...);
      }
    };
  };

  public:
  using type = ::test_cpp2::cpp_reflection::unionA;
  using name = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::unionA;
  using id = type::Type;
  using ids = unionA__struct_unique_identifiers_list;
  using descriptors = ::fatal::list<
    ::fatal::variant_member_descriptor<
      int32_t,
      unionA__struct_unique_identifiers_list::i,
      unionA__struct_unique_getters_list::i,
      unionA__struct_unique_setters_list::i,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::i,
        1,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      double,
      unionA__struct_unique_identifiers_list::d,
      unionA__struct_unique_getters_list::d,
      unionA__struct_unique_setters_list::d,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::d,
        2,
        ::apache::thrift::type_class::floating_point
      >
    >,
    ::fatal::variant_member_descriptor<
      std::string,
      unionA__struct_unique_identifiers_list::s,
      unionA__struct_unique_getters_list::s,
      unionA__struct_unique_setters_list::s,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::s,
        3,
        ::apache::thrift::type_class::string
      >
    >,
    ::fatal::variant_member_descriptor<
       ::test_cpp2::cpp_reflection::enum1,
      unionA__struct_unique_identifiers_list::e,
      unionA__struct_unique_getters_list::e,
      unionA__struct_unique_setters_list::e,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::e,
        4,
        ::apache::thrift::type_class::enumeration
      >
    >,
    ::fatal::variant_member_descriptor<
       ::test_cpp2::cpp_reflection::structA,
      unionA__struct_unique_identifiers_list::a,
      unionA__struct_unique_getters_list::a,
      unionA__struct_unique_setters_list::a,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::a,
        5,
        ::apache::thrift::type_class::structure
      >
    >
  >;

  class annotations {
    struct annotations__unique_annotations_keys {
      using another_annotation = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::another_annotation;
      using sample_annotation = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::sample_annotation;
    };

    struct annotations__unique_annotations_values {
      using another_annotation = ::fatal::sequence<char, 's', 'o', 'm', 'e', ' ', 'm', 'o', 'r', 'e', ' ', 't', 'e', 'x', 't'>;
      using sample_annotation = ::fatal::sequence<char, 's', 'o', 'm', 'e', ' ', 't', 'e', 'x', 't', ' ', 'h', 'e', 'r', 'e'>;
    };

    public:
    using keys = annotations__unique_annotations_keys;
    using values = annotations__unique_annotations_values;
    using map = ::fatal::list<
      ::apache::thrift::annotation<
        keys::another_annotation,
        values::another_annotation
      >,
      ::apache::thrift::annotation<
        keys::sample_annotation,
        values::sample_annotation
      >
    >;
  };

  static id get_id(type const &variant) {
    return variant.getType();
  }

  static bool empty(type const &variant) {
    return variant.getType() == id::__EMPTY__;
  }

  static void clear(type &variant) {
    return variant.__clear();
  }
};

} // thrift_fatal_impl_detail
namespace thrift_fatal_impl_detail {

struct union_with_special_names_Type_enum_traits {
  using type = ::test_cpp2::cpp_reflection::union_with_special_names::Type;
  using name = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::Type;

  struct Type__struct_unique_strings_list {
    using get = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::get;
    using getter = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::getter;
    using lists = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::lists;
    using maps = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::maps;
    using name = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::name;
    using name_to_value = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::name_to_value;
    using names = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::names;
    using prefix_tree = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::prefix_tree;
    using sets = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::sets;
    using setter = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::setter;
    using str = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::str;
    using strings = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::strings;
    using type = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::type;
    using value = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::value;
    using value_to_name = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::value_to_name;
    using values = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::values;
    using id = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::id;
    using ids = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ids;
    using descriptor = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::descriptor;
    using descriptors = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::descriptors;
    using key = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::key;
    using keys = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::keys;
    using annotation = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::annotation;
    using annotations = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::annotations;
    using member = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::member;
    using members = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::members;
  };

  struct Type__struct_enum_members_get {
    using name = Type__struct_unique_strings_list::get;
    using value = std::integral_constant<type, type::get>;
  };

  struct Type__struct_enum_members_getter {
    using name = Type__struct_unique_strings_list::getter;
    using value = std::integral_constant<type, type::getter>;
  };

  struct Type__struct_enum_members_lists {
    using name = Type__struct_unique_strings_list::lists;
    using value = std::integral_constant<type, type::lists>;
  };

  struct Type__struct_enum_members_maps {
    using name = Type__struct_unique_strings_list::maps;
    using value = std::integral_constant<type, type::maps>;
  };

  struct Type__struct_enum_members_name {
    using name = Type__struct_unique_strings_list::name;
    using value = std::integral_constant<type, type::name>;
  };

  struct Type__struct_enum_members_name_to_value {
    using name = Type__struct_unique_strings_list::name_to_value;
    using value = std::integral_constant<type, type::name_to_value>;
  };

  struct Type__struct_enum_members_names {
    using name = Type__struct_unique_strings_list::names;
    using value = std::integral_constant<type, type::names>;
  };

  struct Type__struct_enum_members_prefix_tree {
    using name = Type__struct_unique_strings_list::prefix_tree;
    using value = std::integral_constant<type, type::prefix_tree>;
  };

  struct Type__struct_enum_members_sets {
    using name = Type__struct_unique_strings_list::sets;
    using value = std::integral_constant<type, type::sets>;
  };

  struct Type__struct_enum_members_setter {
    using name = Type__struct_unique_strings_list::setter;
    using value = std::integral_constant<type, type::setter>;
  };

  struct Type__struct_enum_members_str {
    using name = Type__struct_unique_strings_list::str;
    using value = std::integral_constant<type, type::str>;
  };

  struct Type__struct_enum_members_strings {
    using name = Type__struct_unique_strings_list::strings;
    using value = std::integral_constant<type, type::strings>;
  };

  struct Type__struct_enum_members_type {
    using name = Type__struct_unique_strings_list::type;
    using value = std::integral_constant<type, type::type>;
  };

  struct Type__struct_enum_members_value {
    using name = Type__struct_unique_strings_list::value;
    using value = std::integral_constant<type, type::value>;
  };

  struct Type__struct_enum_members_value_to_name {
    using name = Type__struct_unique_strings_list::value_to_name;
    using value = std::integral_constant<type, type::value_to_name>;
  };

  struct Type__struct_enum_members_values {
    using name = Type__struct_unique_strings_list::values;
    using value = std::integral_constant<type, type::values>;
  };

  struct Type__struct_enum_members_id {
    using name = Type__struct_unique_strings_list::id;
    using value = std::integral_constant<type, type::id>;
  };

  struct Type__struct_enum_members_ids {
    using name = Type__struct_unique_strings_list::ids;
    using value = std::integral_constant<type, type::ids>;
  };

  struct Type__struct_enum_members_descriptor {
    using name = Type__struct_unique_strings_list::descriptor;
    using value = std::integral_constant<type, type::descriptor>;
  };

  struct Type__struct_enum_members_descriptors {
    using name = Type__struct_unique_strings_list::descriptors;
    using value = std::integral_constant<type, type::descriptors>;
  };

  struct Type__struct_enum_members_key {
    using name = Type__struct_unique_strings_list::key;
    using value = std::integral_constant<type, type::key>;
  };

  struct Type__struct_enum_members_keys {
    using name = Type__struct_unique_strings_list::keys;
    using value = std::integral_constant<type, type::keys>;
  };

  struct Type__struct_enum_members_annotation {
    using name = Type__struct_unique_strings_list::annotation;
    using value = std::integral_constant<type, type::annotation>;
  };

  struct Type__struct_enum_members_annotations {
    using name = Type__struct_unique_strings_list::annotations;
    using value = std::integral_constant<type, type::annotations>;
  };

  struct Type__struct_enum_members_member {
    using name = Type__struct_unique_strings_list::member;
    using value = std::integral_constant<type, type::member>;
  };

  struct Type__struct_enum_members_members {
    using name = Type__struct_unique_strings_list::members;
    using value = std::integral_constant<type, type::members>;
  };

  struct Type__struct_enum_members {
    using get = Type__struct_enum_members_get;
    using getter = Type__struct_enum_members_getter;
    using lists = Type__struct_enum_members_lists;
    using maps = Type__struct_enum_members_maps;
    using name = Type__struct_enum_members_name;
    using name_to_value = Type__struct_enum_members_name_to_value;
    using names = Type__struct_enum_members_names;
    using prefix_tree = Type__struct_enum_members_prefix_tree;
    using sets = Type__struct_enum_members_sets;
    using setter = Type__struct_enum_members_setter;
    using str = Type__struct_enum_members_str;
    using strings = Type__struct_enum_members_strings;
    using type = Type__struct_enum_members_type;
    using value = Type__struct_enum_members_value;
    using value_to_name = Type__struct_enum_members_value_to_name;
    using values = Type__struct_enum_members_values;
    using id = Type__struct_enum_members_id;
    using ids = Type__struct_enum_members_ids;
    using descriptor = Type__struct_enum_members_descriptor;
    using descriptors = Type__struct_enum_members_descriptors;
    using key = Type__struct_enum_members_key;
    using keys = Type__struct_enum_members_keys;
    using annotation = Type__struct_enum_members_annotation;
    using annotations = Type__struct_enum_members_annotations;
    using member = Type__struct_enum_members_member;
    using members = Type__struct_enum_members_members;
  };

  using member = Type__struct_enum_members;

  using fields = ::fatal::list<
      member::get,
      member::getter,
      member::lists,
      member::maps,
      member::name,
      member::name_to_value,
      member::names,
      member::prefix_tree,
      member::sets,
      member::setter,
      member::str,
      member::strings,
      member::type,
      member::value,
      member::value_to_name,
      member::values,
      member::id,
      member::ids,
      member::descriptor,
      member::descriptors,
      member::key,
      member::keys,
      member::annotation,
      member::annotations,
      member::member,
      member::members
  >;

  class annotations {
    struct annotations__unique_annotations_keys {};

    struct annotations__unique_annotations_values {};

    public:
    using keys = annotations__unique_annotations_keys;
    using values = annotations__unique_annotations_values;
    using map = ::fatal::list<
    >;
  };

  static char const *to_string(type e, char const *fallback) {
    switch (e) {
      case type::get: return "get";
      case type::getter: return "getter";
      case type::lists: return "lists";
      case type::maps: return "maps";
      case type::name: return "name";
      case type::name_to_value: return "name_to_value";
      case type::names: return "names";
      case type::prefix_tree: return "prefix_tree";
      case type::sets: return "sets";
      case type::setter: return "setter";
      case type::str: return "str";
      case type::strings: return "strings";
      case type::type: return "type";
      case type::value: return "value";
      case type::value_to_name: return "value_to_name";
      case type::values: return "values";
      case type::id: return "id";
      case type::ids: return "ids";
      case type::descriptor: return "descriptor";
      case type::descriptors: return "descriptors";
      case type::key: return "key";
      case type::keys: return "keys";
      case type::annotation: return "annotation";
      case type::annotations: return "annotations";
      case type::member: return "member";
      case type::members: return "members";
      default: return fallback;
    }
  }
};

} // thrift_fatal_impl_detail

FATAL_REGISTER_ENUM_TRAITS(
  ::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union_with_special_names_Type_enum_traits,
  ::apache::thrift::detail::type_common_metadata_impl<
    module_tags::module,
    ::apache::thrift::reflected_annotations<::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union_with_special_names_Type_enum_traits::annotations>,
    static_cast<::apache::thrift::legacy_type_id_t>(0ull)
  >
);

namespace thrift_fatal_impl_detail {

class union_with_special_names_variant_traits {
  struct union_with_special_names__struct_unique_identifiers_list {
    using get = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::get>;
    using getter = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::getter>;
    using lists = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::lists>;
    using maps = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::maps>;
    using name = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::name>;
    using name_to_value = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::name_to_value>;
    using names = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::names>;
    using prefix_tree = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::prefix_tree>;
    using sets = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::sets>;
    using setter = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::setter>;
    using str = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::str>;
    using strings = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::strings>;
    using type = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::type>;
    using value = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::value>;
    using value_to_name = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::value_to_name>;
    using values = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::values>;
    using id = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::id>;
    using ids = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::ids>;
    using descriptor = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::descriptor>;
    using descriptors = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::descriptors>;
    using key = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::key>;
    using keys = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::keys>;
    using annotation = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::annotation>;
    using annotations = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::annotations>;
    using member = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::member>;
    using members = std::integral_constant<::test_cpp2::cpp_reflection::union_with_special_names::Type, ::test_cpp2::cpp_reflection::union_with_special_names::Type::members>;
  };

  struct union_with_special_names__struct_unique_getters_list {
    struct get {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_get())
      {
        return variant.get_get();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_get())
      {
        return variant.mutable_get();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_get())
      {
        return std::move(variant).move_get();
      }
    };

    struct getter {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_getter())
      {
        return variant.get_getter();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_getter())
      {
        return variant.mutable_getter();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_getter())
      {
        return std::move(variant).move_getter();
      }
    };

    struct lists {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_lists())
      {
        return variant.get_lists();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_lists())
      {
        return variant.mutable_lists();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_lists())
      {
        return std::move(variant).move_lists();
      }
    };

    struct maps {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_maps())
      {
        return variant.get_maps();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_maps())
      {
        return variant.mutable_maps();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_maps())
      {
        return std::move(variant).move_maps();
      }
    };

    struct name {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_name())
      {
        return variant.get_name();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_name())
      {
        return variant.mutable_name();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_name())
      {
        return std::move(variant).move_name();
      }
    };

    struct name_to_value {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_name_to_value())
      {
        return variant.get_name_to_value();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_name_to_value())
      {
        return variant.mutable_name_to_value();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_name_to_value())
      {
        return std::move(variant).move_name_to_value();
      }
    };

    struct names {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_names())
      {
        return variant.get_names();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_names())
      {
        return variant.mutable_names();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_names())
      {
        return std::move(variant).move_names();
      }
    };

    struct prefix_tree {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_prefix_tree())
      {
        return variant.get_prefix_tree();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_prefix_tree())
      {
        return variant.mutable_prefix_tree();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_prefix_tree())
      {
        return std::move(variant).move_prefix_tree();
      }
    };

    struct sets {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_sets())
      {
        return variant.get_sets();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_sets())
      {
        return variant.mutable_sets();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_sets())
      {
        return std::move(variant).move_sets();
      }
    };

    struct setter {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_setter())
      {
        return variant.get_setter();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_setter())
      {
        return variant.mutable_setter();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_setter())
      {
        return std::move(variant).move_setter();
      }
    };

    struct str {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_str())
      {
        return variant.get_str();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_str())
      {
        return variant.mutable_str();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_str())
      {
        return std::move(variant).move_str();
      }
    };

    struct strings {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_strings())
      {
        return variant.get_strings();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_strings())
      {
        return variant.mutable_strings();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_strings())
      {
        return std::move(variant).move_strings();
      }
    };

    struct type {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_type())
      {
        return variant.get_type();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_type())
      {
        return variant.mutable_type();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_type())
      {
        return std::move(variant).move_type();
      }
    };

    struct value {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_value())
      {
        return variant.get_value();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_value())
      {
        return variant.mutable_value();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_value())
      {
        return std::move(variant).move_value();
      }
    };

    struct value_to_name {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_value_to_name())
      {
        return variant.get_value_to_name();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_value_to_name())
      {
        return variant.mutable_value_to_name();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_value_to_name())
      {
        return std::move(variant).move_value_to_name();
      }
    };

    struct values {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_values())
      {
        return variant.get_values();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_values())
      {
        return variant.mutable_values();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_values())
      {
        return std::move(variant).move_values();
      }
    };

    struct id {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_id())
      {
        return variant.get_id();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_id())
      {
        return variant.mutable_id();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_id())
      {
        return std::move(variant).move_id();
      }
    };

    struct ids {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_ids())
      {
        return variant.get_ids();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_ids())
      {
        return variant.mutable_ids();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_ids())
      {
        return std::move(variant).move_ids();
      }
    };

    struct descriptor {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_descriptor())
      {
        return variant.get_descriptor();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_descriptor())
      {
        return variant.mutable_descriptor();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_descriptor())
      {
        return std::move(variant).move_descriptor();
      }
    };

    struct descriptors {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_descriptors())
      {
        return variant.get_descriptors();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_descriptors())
      {
        return variant.mutable_descriptors();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_descriptors())
      {
        return std::move(variant).move_descriptors();
      }
    };

    struct key {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_key())
      {
        return variant.get_key();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_key())
      {
        return variant.mutable_key();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_key())
      {
        return std::move(variant).move_key();
      }
    };

    struct keys {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_keys())
      {
        return variant.get_keys();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_keys())
      {
        return variant.mutable_keys();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_keys())
      {
        return std::move(variant).move_keys();
      }
    };

    struct annotation {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_annotation())
      {
        return variant.get_annotation();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_annotation())
      {
        return variant.mutable_annotation();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_annotation())
      {
        return std::move(variant).move_annotation();
      }
    };

    struct annotations {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_annotations())
      {
        return variant.get_annotations();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_annotations())
      {
        return variant.mutable_annotations();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_annotations())
      {
        return std::move(variant).move_annotations();
      }
    };

    struct member {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_member())
      {
        return variant.get_member();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_member())
      {
        return variant.mutable_member();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_member())
      {
        return std::move(variant).move_member();
      }
    };

    struct members {
      auto operator ()(union_with_special_names const &variant) const
        -> decltype(std::declval<union_with_special_names const &>().get_members())
      {
        return variant.get_members();
      }

      auto operator ()(union_with_special_names &variant) const
        -> decltype(std::declval<union_with_special_names &>().mutable_members())
      {
        return variant.mutable_members();
      }

      auto operator ()(union_with_special_names &&variant) const
        -> decltype(std::declval<union_with_special_names &&>().move_members())
      {
        return std::move(variant).move_members();
      }
    };
  };

  struct union_with_special_names__struct_unique_setters_list {
    struct get {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_get(std::forward<Args>(args)...)
        )
      {
        return variant.set_get(std::forward<Args>(args)...);
      }
    };

    struct getter {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_getter(std::forward<Args>(args)...)
        )
      {
        return variant.set_getter(std::forward<Args>(args)...);
      }
    };

    struct lists {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_lists(std::forward<Args>(args)...)
        )
      {
        return variant.set_lists(std::forward<Args>(args)...);
      }
    };

    struct maps {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_maps(std::forward<Args>(args)...)
        )
      {
        return variant.set_maps(std::forward<Args>(args)...);
      }
    };

    struct name {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_name(std::forward<Args>(args)...)
        )
      {
        return variant.set_name(std::forward<Args>(args)...);
      }
    };

    struct name_to_value {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_name_to_value(std::forward<Args>(args)...)
        )
      {
        return variant.set_name_to_value(std::forward<Args>(args)...);
      }
    };

    struct names {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_names(std::forward<Args>(args)...)
        )
      {
        return variant.set_names(std::forward<Args>(args)...);
      }
    };

    struct prefix_tree {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_prefix_tree(std::forward<Args>(args)...)
        )
      {
        return variant.set_prefix_tree(std::forward<Args>(args)...);
      }
    };

    struct sets {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_sets(std::forward<Args>(args)...)
        )
      {
        return variant.set_sets(std::forward<Args>(args)...);
      }
    };

    struct setter {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_setter(std::forward<Args>(args)...)
        )
      {
        return variant.set_setter(std::forward<Args>(args)...);
      }
    };

    struct str {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_str(std::forward<Args>(args)...)
        )
      {
        return variant.set_str(std::forward<Args>(args)...);
      }
    };

    struct strings {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_strings(std::forward<Args>(args)...)
        )
      {
        return variant.set_strings(std::forward<Args>(args)...);
      }
    };

    struct type {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_type(std::forward<Args>(args)...)
        )
      {
        return variant.set_type(std::forward<Args>(args)...);
      }
    };

    struct value {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_value(std::forward<Args>(args)...)
        )
      {
        return variant.set_value(std::forward<Args>(args)...);
      }
    };

    struct value_to_name {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_value_to_name(std::forward<Args>(args)...)
        )
      {
        return variant.set_value_to_name(std::forward<Args>(args)...);
      }
    };

    struct values {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_values(std::forward<Args>(args)...)
        )
      {
        return variant.set_values(std::forward<Args>(args)...);
      }
    };

    struct id {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_id(std::forward<Args>(args)...)
        )
      {
        return variant.set_id(std::forward<Args>(args)...);
      }
    };

    struct ids {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_ids(std::forward<Args>(args)...)
        )
      {
        return variant.set_ids(std::forward<Args>(args)...);
      }
    };

    struct descriptor {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_descriptor(std::forward<Args>(args)...)
        )
      {
        return variant.set_descriptor(std::forward<Args>(args)...);
      }
    };

    struct descriptors {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_descriptors(std::forward<Args>(args)...)
        )
      {
        return variant.set_descriptors(std::forward<Args>(args)...);
      }
    };

    struct key {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_key(std::forward<Args>(args)...)
        )
      {
        return variant.set_key(std::forward<Args>(args)...);
      }
    };

    struct keys {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_keys(std::forward<Args>(args)...)
        )
      {
        return variant.set_keys(std::forward<Args>(args)...);
      }
    };

    struct annotation {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_annotation(std::forward<Args>(args)...)
        )
      {
        return variant.set_annotation(std::forward<Args>(args)...);
      }
    };

    struct annotations {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_annotations(std::forward<Args>(args)...)
        )
      {
        return variant.set_annotations(std::forward<Args>(args)...);
      }
    };

    struct member {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_member(std::forward<Args>(args)...)
        )
      {
        return variant.set_member(std::forward<Args>(args)...);
      }
    };

    struct members {
      template <typename... Args>
      auto operator ()(union_with_special_names &variant, Args &&...args) const
        -> decltype(
          std::declval<union_with_special_names &>().set_members(std::forward<Args>(args)...)
        )
      {
        return variant.set_members(std::forward<Args>(args)...);
      }
    };
  };

  public:
  using type = ::test_cpp2::cpp_reflection::union_with_special_names;
  using name = thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::union_with_special_names;
  using id = type::Type;
  using ids = union_with_special_names__struct_unique_identifiers_list;
  using descriptors = ::fatal::list<
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::get,
      union_with_special_names__struct_unique_getters_list::get,
      union_with_special_names__struct_unique_setters_list::get,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::get,
        1,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::getter,
      union_with_special_names__struct_unique_getters_list::getter,
      union_with_special_names__struct_unique_setters_list::getter,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::getter,
        2,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::lists,
      union_with_special_names__struct_unique_getters_list::lists,
      union_with_special_names__struct_unique_setters_list::lists,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::lists,
        3,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::maps,
      union_with_special_names__struct_unique_getters_list::maps,
      union_with_special_names__struct_unique_setters_list::maps,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::maps,
        4,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::name,
      union_with_special_names__struct_unique_getters_list::name,
      union_with_special_names__struct_unique_setters_list::name,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::name,
        5,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::name_to_value,
      union_with_special_names__struct_unique_getters_list::name_to_value,
      union_with_special_names__struct_unique_setters_list::name_to_value,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::name_to_value,
        6,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::names,
      union_with_special_names__struct_unique_getters_list::names,
      union_with_special_names__struct_unique_setters_list::names,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::names,
        7,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::prefix_tree,
      union_with_special_names__struct_unique_getters_list::prefix_tree,
      union_with_special_names__struct_unique_setters_list::prefix_tree,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::prefix_tree,
        8,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::sets,
      union_with_special_names__struct_unique_getters_list::sets,
      union_with_special_names__struct_unique_setters_list::sets,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::sets,
        9,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::setter,
      union_with_special_names__struct_unique_getters_list::setter,
      union_with_special_names__struct_unique_setters_list::setter,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::setter,
        10,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::str,
      union_with_special_names__struct_unique_getters_list::str,
      union_with_special_names__struct_unique_setters_list::str,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::str,
        11,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::strings,
      union_with_special_names__struct_unique_getters_list::strings,
      union_with_special_names__struct_unique_setters_list::strings,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::strings,
        12,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::type,
      union_with_special_names__struct_unique_getters_list::type,
      union_with_special_names__struct_unique_setters_list::type,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::type,
        13,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::value,
      union_with_special_names__struct_unique_getters_list::value,
      union_with_special_names__struct_unique_setters_list::value,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::value,
        14,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::value_to_name,
      union_with_special_names__struct_unique_getters_list::value_to_name,
      union_with_special_names__struct_unique_setters_list::value_to_name,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::value_to_name,
        15,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::values,
      union_with_special_names__struct_unique_getters_list::values,
      union_with_special_names__struct_unique_setters_list::values,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::values,
        16,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::id,
      union_with_special_names__struct_unique_getters_list::id,
      union_with_special_names__struct_unique_setters_list::id,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::id,
        17,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::ids,
      union_with_special_names__struct_unique_getters_list::ids,
      union_with_special_names__struct_unique_setters_list::ids,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::ids,
        18,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::descriptor,
      union_with_special_names__struct_unique_getters_list::descriptor,
      union_with_special_names__struct_unique_setters_list::descriptor,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::descriptor,
        19,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::descriptors,
      union_with_special_names__struct_unique_getters_list::descriptors,
      union_with_special_names__struct_unique_setters_list::descriptors,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::descriptors,
        20,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::key,
      union_with_special_names__struct_unique_getters_list::key,
      union_with_special_names__struct_unique_setters_list::key,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::key,
        21,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::keys,
      union_with_special_names__struct_unique_getters_list::keys,
      union_with_special_names__struct_unique_setters_list::keys,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::keys,
        22,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::annotation,
      union_with_special_names__struct_unique_getters_list::annotation,
      union_with_special_names__struct_unique_setters_list::annotation,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::annotation,
        23,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::annotations,
      union_with_special_names__struct_unique_getters_list::annotations,
      union_with_special_names__struct_unique_setters_list::annotations,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::annotations,
        24,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::member,
      union_with_special_names__struct_unique_getters_list::member,
      union_with_special_names__struct_unique_setters_list::member,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::member,
        25,
        ::apache::thrift::type_class::integral
      >
    >,
    ::fatal::variant_member_descriptor<
      int32_t,
      union_with_special_names__struct_unique_identifiers_list::members,
      union_with_special_names__struct_unique_getters_list::members,
      union_with_special_names__struct_unique_setters_list::members,
      ::apache::thrift::reflected_variant_member_metadata<
        thrift_fatal_impl_detail::test_cpp2_cpp_reflection_module__unique_strings_list::members,
        26,
        ::apache::thrift::type_class::integral
      >
    >
  >;

  class annotations {
    struct annotations__unique_annotations_keys {};

    struct annotations__unique_annotations_values {};

    public:
    using keys = annotations__unique_annotations_keys;
    using values = annotations__unique_annotations_values;
    using map = ::fatal::list<
    >;
  };

  static id get_id(type const &variant) {
    return variant.getType();
  }

  static bool empty(type const &variant) {
    return variant.getType() == id::__EMPTY__;
  }

  static void clear(type &variant) {
    return variant.__clear();
  }
};

} // thrift_fatal_impl_detail

FATAL_REGISTER_VARIANT_TRAITS(
  ::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union1_variant_traits,
  ::apache::thrift::detail::type_common_metadata_impl<
    module_tags::module,
    ::apache::thrift::reflected_annotations<::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union1_variant_traits::annotations>,
    static_cast<::apache::thrift::legacy_type_id_t>(7384876196182105420ull)
  >
);
FATAL_REGISTER_VARIANT_TRAITS(
  ::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union2_variant_traits,
  ::apache::thrift::detail::type_common_metadata_impl<
    module_tags::module,
    ::apache::thrift::reflected_annotations<::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union2_variant_traits::annotations>,
    static_cast<::apache::thrift::legacy_type_id_t>(16722894251049030828ull)
  >
);
FATAL_REGISTER_VARIANT_TRAITS(
  ::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union3_variant_traits,
  ::apache::thrift::detail::type_common_metadata_impl<
    module_tags::module,
    ::apache::thrift::reflected_annotations<::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union3_variant_traits::annotations>,
    static_cast<::apache::thrift::legacy_type_id_t>(12878995471701578764ull)
  >
);
FATAL_REGISTER_VARIANT_TRAITS(
  ::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::unionA_variant_traits,
  ::apache::thrift::detail::type_common_metadata_impl<
    module_tags::module,
    ::apache::thrift::reflected_annotations<::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::unionA_variant_traits::annotations>,
    static_cast<::apache::thrift::legacy_type_id_t>(7943717058393504940ull)
  >
);
FATAL_REGISTER_VARIANT_TRAITS(
  ::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union_with_special_names_variant_traits,
  ::apache::thrift::detail::type_common_metadata_impl<
    module_tags::module,
    ::apache::thrift::reflected_annotations<::test_cpp2::cpp_reflection::thrift_fatal_impl_detail::union_with_special_names_variant_traits::annotations>,
    static_cast<::apache::thrift::legacy_type_id_t>(7581402120603624460ull)
  >
);

}} // test_cpp2::cpp_reflection

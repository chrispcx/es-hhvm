/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package thrift.test;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.facebook.thrift.*;
import com.facebook.thrift.async.*;
import com.facebook.thrift.meta_data.*;
import com.facebook.thrift.server.*;
import com.facebook.thrift.transport.*;
import com.facebook.thrift.protocol.*;

@SuppressWarnings({ "unused", "serial" })
public class RandomStuff implements TBase, java.io.Serializable, Cloneable, Comparable<RandomStuff> {
  private static final TStruct STRUCT_DESC = new TStruct("RandomStuff");
  private static final TField A_FIELD_DESC = new TField("a", TType.I32, (short)1);
  private static final TField B_FIELD_DESC = new TField("b", TType.I32, (short)2);
  private static final TField C_FIELD_DESC = new TField("c", TType.I32, (short)3);
  private static final TField D_FIELD_DESC = new TField("d", TType.I32, (short)4);
  private static final TField MYINTLIST_FIELD_DESC = new TField("myintlist", TType.LIST, (short)5);
  private static final TField MAPS_FIELD_DESC = new TField("maps", TType.MAP, (short)6);
  private static final TField BIGINT_FIELD_DESC = new TField("bigint", TType.I64, (short)7);
  private static final TField TRIPLE_FIELD_DESC = new TField("triple", TType.DOUBLE, (short)8);

  public int a;
  public int b;
  public int c;
  public int d;
  public List<Integer> myintlist;
  public Map<Integer,Wrapper> maps;
  public long bigint;
  public double triple;
  public static final int A = 1;
  public static final int B = 2;
  public static final int C = 3;
  public static final int D = 4;
  public static final int MYINTLIST = 5;
  public static final int MAPS = 6;
  public static final int BIGINT = 7;
  public static final int TRIPLE = 8;
  public static boolean DEFAULT_PRETTY_PRINT = true;

  // isset id assignments
  private static final int __A_ISSET_ID = 0;
  private static final int __B_ISSET_ID = 1;
  private static final int __C_ISSET_ID = 2;
  private static final int __D_ISSET_ID = 3;
  private static final int __BIGINT_ISSET_ID = 4;
  private static final int __TRIPLE_ISSET_ID = 5;
  private BitSet __isset_bit_vector = new BitSet(6);

  public static final Map<Integer, FieldMetaData> metaDataMap;
  static {
    Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
    tmpMetaDataMap.put(A, new FieldMetaData("a", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32)));
    tmpMetaDataMap.put(B, new FieldMetaData("b", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32)));
    tmpMetaDataMap.put(C, new FieldMetaData("c", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32)));
    tmpMetaDataMap.put(D, new FieldMetaData("d", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32)));
    tmpMetaDataMap.put(MYINTLIST, new FieldMetaData("myintlist", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new FieldValueMetaData(TType.I32))));
    tmpMetaDataMap.put(MAPS, new FieldMetaData("maps", TFieldRequirementType.DEFAULT, 
        new MapMetaData(TType.MAP, 
            new FieldValueMetaData(TType.I32), 
            new StructMetaData(TType.STRUCT, Wrapper.class))));
    tmpMetaDataMap.put(BIGINT, new FieldMetaData("bigint", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I64)));
    tmpMetaDataMap.put(TRIPLE, new FieldMetaData("triple", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.DOUBLE)));
    metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
  }

  static {
    FieldMetaData.addStructMetaDataMap(RandomStuff.class, metaDataMap);
  }

  public RandomStuff() {
  }

  public RandomStuff(
    int a,
    int b,
    int c,
    int d,
    List<Integer> myintlist,
    Map<Integer,Wrapper> maps,
    long bigint,
    double triple)
  {
    this();
    this.a = a;
    setAIsSet(true);
    this.b = b;
    setBIsSet(true);
    this.c = c;
    setCIsSet(true);
    this.d = d;
    setDIsSet(true);
    this.myintlist = myintlist;
    this.maps = maps;
    this.bigint = bigint;
    setBigintIsSet(true);
    this.triple = triple;
    setTripleIsSet(true);
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public RandomStuff(RandomStuff other) {
    __isset_bit_vector.clear();
    __isset_bit_vector.or(other.__isset_bit_vector);
    this.a = TBaseHelper.deepCopy(other.a);
    this.b = TBaseHelper.deepCopy(other.b);
    this.c = TBaseHelper.deepCopy(other.c);
    this.d = TBaseHelper.deepCopy(other.d);
    if (other.isSetMyintlist()) {
      this.myintlist = TBaseHelper.deepCopy(other.myintlist);
    }
    if (other.isSetMaps()) {
      this.maps = TBaseHelper.deepCopy(other.maps);
    }
    this.bigint = TBaseHelper.deepCopy(other.bigint);
    this.triple = TBaseHelper.deepCopy(other.triple);
  }

  public RandomStuff deepCopy() {
    return new RandomStuff(this);
  }

  @Deprecated
  public RandomStuff clone() {
    return new RandomStuff(this);
  }

  public int  getA() {
    return this.a;
  }

  public RandomStuff setA(int a) {
    this.a = a;
    setAIsSet(true);
    return this;
  }

  public void unsetA() {
    __isset_bit_vector.clear(__A_ISSET_ID);
  }

  // Returns true if field a is set (has been assigned a value) and false otherwise
  public boolean isSetA() {
    return __isset_bit_vector.get(__A_ISSET_ID);
  }

  public void setAIsSet(boolean value) {
    __isset_bit_vector.set(__A_ISSET_ID, value);
  }

  public int  getB() {
    return this.b;
  }

  public RandomStuff setB(int b) {
    this.b = b;
    setBIsSet(true);
    return this;
  }

  public void unsetB() {
    __isset_bit_vector.clear(__B_ISSET_ID);
  }

  // Returns true if field b is set (has been assigned a value) and false otherwise
  public boolean isSetB() {
    return __isset_bit_vector.get(__B_ISSET_ID);
  }

  public void setBIsSet(boolean value) {
    __isset_bit_vector.set(__B_ISSET_ID, value);
  }

  public int  getC() {
    return this.c;
  }

  public RandomStuff setC(int c) {
    this.c = c;
    setCIsSet(true);
    return this;
  }

  public void unsetC() {
    __isset_bit_vector.clear(__C_ISSET_ID);
  }

  // Returns true if field c is set (has been assigned a value) and false otherwise
  public boolean isSetC() {
    return __isset_bit_vector.get(__C_ISSET_ID);
  }

  public void setCIsSet(boolean value) {
    __isset_bit_vector.set(__C_ISSET_ID, value);
  }

  public int  getD() {
    return this.d;
  }

  public RandomStuff setD(int d) {
    this.d = d;
    setDIsSet(true);
    return this;
  }

  public void unsetD() {
    __isset_bit_vector.clear(__D_ISSET_ID);
  }

  // Returns true if field d is set (has been assigned a value) and false otherwise
  public boolean isSetD() {
    return __isset_bit_vector.get(__D_ISSET_ID);
  }

  public void setDIsSet(boolean value) {
    __isset_bit_vector.set(__D_ISSET_ID, value);
  }

  public List<Integer>  getMyintlist() {
    return this.myintlist;
  }

  public RandomStuff setMyintlist(List<Integer> myintlist) {
    this.myintlist = myintlist;
    return this;
  }

  public void unsetMyintlist() {
    this.myintlist = null;
  }

  // Returns true if field myintlist is set (has been assigned a value) and false otherwise
  public boolean isSetMyintlist() {
    return this.myintlist != null;
  }

  public void setMyintlistIsSet(boolean value) {
    if (!value) {
      this.myintlist = null;
    }
  }

  public Map<Integer,Wrapper>  getMaps() {
    return this.maps;
  }

  public RandomStuff setMaps(Map<Integer,Wrapper> maps) {
    this.maps = maps;
    return this;
  }

  public void unsetMaps() {
    this.maps = null;
  }

  // Returns true if field maps is set (has been assigned a value) and false otherwise
  public boolean isSetMaps() {
    return this.maps != null;
  }

  public void setMapsIsSet(boolean value) {
    if (!value) {
      this.maps = null;
    }
  }

  public long  getBigint() {
    return this.bigint;
  }

  public RandomStuff setBigint(long bigint) {
    this.bigint = bigint;
    setBigintIsSet(true);
    return this;
  }

  public void unsetBigint() {
    __isset_bit_vector.clear(__BIGINT_ISSET_ID);
  }

  // Returns true if field bigint is set (has been assigned a value) and false otherwise
  public boolean isSetBigint() {
    return __isset_bit_vector.get(__BIGINT_ISSET_ID);
  }

  public void setBigintIsSet(boolean value) {
    __isset_bit_vector.set(__BIGINT_ISSET_ID, value);
  }

  public double  getTriple() {
    return this.triple;
  }

  public RandomStuff setTriple(double triple) {
    this.triple = triple;
    setTripleIsSet(true);
    return this;
  }

  public void unsetTriple() {
    __isset_bit_vector.clear(__TRIPLE_ISSET_ID);
  }

  // Returns true if field triple is set (has been assigned a value) and false otherwise
  public boolean isSetTriple() {
    return __isset_bit_vector.get(__TRIPLE_ISSET_ID);
  }

  public void setTripleIsSet(boolean value) {
    __isset_bit_vector.set(__TRIPLE_ISSET_ID, value);
  }

  @SuppressWarnings("unchecked")
  public void setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
    case A:
      if (value == null) {
        unsetA();
      } else {
        setA((Integer)value);
      }
      break;

    case B:
      if (value == null) {
        unsetB();
      } else {
        setB((Integer)value);
      }
      break;

    case C:
      if (value == null) {
        unsetC();
      } else {
        setC((Integer)value);
      }
      break;

    case D:
      if (value == null) {
        unsetD();
      } else {
        setD((Integer)value);
      }
      break;

    case MYINTLIST:
      if (value == null) {
        unsetMyintlist();
      } else {
        setMyintlist((List<Integer>)value);
      }
      break;

    case MAPS:
      if (value == null) {
        unsetMaps();
      } else {
        setMaps((Map<Integer,Wrapper>)value);
      }
      break;

    case BIGINT:
      if (value == null) {
        unsetBigint();
      } else {
        setBigint((Long)value);
      }
      break;

    case TRIPLE:
      if (value == null) {
        unsetTriple();
      } else {
        setTriple((Double)value);
      }
      break;

    default:
      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
    }
  }

  public Object getFieldValue(int fieldID) {
    switch (fieldID) {
    case A:
      return new Integer(getA());

    case B:
      return new Integer(getB());

    case C:
      return new Integer(getC());

    case D:
      return new Integer(getD());

    case MYINTLIST:
      return getMyintlist();

    case MAPS:
      return getMaps();

    case BIGINT:
      return new Long(getBigint());

    case TRIPLE:
      return new Double(getTriple());

    default:
      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public boolean isSet(int fieldID) {
    switch (fieldID) {
    case A:
      return isSetA();
    case B:
      return isSetB();
    case C:
      return isSetC();
    case D:
      return isSetD();
    case MYINTLIST:
      return isSetMyintlist();
    case MAPS:
      return isSetMaps();
    case BIGINT:
      return isSetBigint();
    case TRIPLE:
      return isSetTriple();
    default:
      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
    }
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof RandomStuff)
      return this.equals((RandomStuff)that);
    return false;
  }

  public boolean equals(RandomStuff that) {
    if (that == null)
      return false;
    if (this == that)
      return true;

    boolean this_present_a = true;
    boolean that_present_a = true;
    if (this_present_a || that_present_a) {
      if (!(this_present_a && that_present_a))
        return false;
      if (!TBaseHelper.equalsNobinary(this.a, that.a))
        return false;
    }

    boolean this_present_b = true;
    boolean that_present_b = true;
    if (this_present_b || that_present_b) {
      if (!(this_present_b && that_present_b))
        return false;
      if (!TBaseHelper.equalsNobinary(this.b, that.b))
        return false;
    }

    boolean this_present_c = true;
    boolean that_present_c = true;
    if (this_present_c || that_present_c) {
      if (!(this_present_c && that_present_c))
        return false;
      if (!TBaseHelper.equalsNobinary(this.c, that.c))
        return false;
    }

    boolean this_present_d = true;
    boolean that_present_d = true;
    if (this_present_d || that_present_d) {
      if (!(this_present_d && that_present_d))
        return false;
      if (!TBaseHelper.equalsNobinary(this.d, that.d))
        return false;
    }

    boolean this_present_myintlist = true && this.isSetMyintlist();
    boolean that_present_myintlist = true && that.isSetMyintlist();
    if (this_present_myintlist || that_present_myintlist) {
      if (!(this_present_myintlist && that_present_myintlist))
        return false;
      if (!TBaseHelper.equalsNobinary(this.myintlist, that.myintlist))
        return false;
    }

    boolean this_present_maps = true && this.isSetMaps();
    boolean that_present_maps = true && that.isSetMaps();
    if (this_present_maps || that_present_maps) {
      if (!(this_present_maps && that_present_maps))
        return false;
      if (!TBaseHelper.equalsNobinary(this.maps, that.maps))
        return false;
    }

    boolean this_present_bigint = true;
    boolean that_present_bigint = true;
    if (this_present_bigint || that_present_bigint) {
      if (!(this_present_bigint && that_present_bigint))
        return false;
      if (!TBaseHelper.equalsNobinary(this.bigint, that.bigint))
        return false;
    }

    boolean this_present_triple = true;
    boolean that_present_triple = true;
    if (this_present_triple || that_present_triple) {
      if (!(this_present_triple && that_present_triple))
        return false;
      if (!TBaseHelper.equalsNobinary(this.triple, that.triple))
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    return 0;
  }

  @Override
  public int compareTo(RandomStuff other) {
    if (other == null) {
      // See java.lang.Comparable docs
      throw new NullPointerException();
    }

    if (other == this) {
      return 0;
    }
    int lastComparison = 0;

    lastComparison = Boolean.valueOf(isSetA()).compareTo(other.isSetA());
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = TBaseHelper.compareTo(a, other.a);
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = Boolean.valueOf(isSetB()).compareTo(other.isSetB());
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = TBaseHelper.compareTo(b, other.b);
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = Boolean.valueOf(isSetC()).compareTo(other.isSetC());
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = TBaseHelper.compareTo(c, other.c);
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = Boolean.valueOf(isSetD()).compareTo(other.isSetD());
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = TBaseHelper.compareTo(d, other.d);
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = Boolean.valueOf(isSetMyintlist()).compareTo(other.isSetMyintlist());
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = TBaseHelper.compareTo(myintlist, other.myintlist);
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = Boolean.valueOf(isSetMaps()).compareTo(other.isSetMaps());
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = TBaseHelper.compareTo(maps, other.maps);
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = Boolean.valueOf(isSetBigint()).compareTo(other.isSetBigint());
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = TBaseHelper.compareTo(bigint, other.bigint);
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = Boolean.valueOf(isSetTriple()).compareTo(other.isSetTriple());
    if (lastComparison != 0) {
      return lastComparison;
    }
    lastComparison = TBaseHelper.compareTo(triple, other.triple);
    if (lastComparison != 0) {
      return lastComparison;
    }
    return 0;
  }

  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin(metaDataMap);
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case A:
          if (field.type == TType.I32) {
            this.a = iprot.readI32();
            setAIsSet(true);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case B:
          if (field.type == TType.I32) {
            this.b = iprot.readI32();
            setBIsSet(true);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case C:
          if (field.type == TType.I32) {
            this.c = iprot.readI32();
            setCIsSet(true);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case D:
          if (field.type == TType.I32) {
            this.d = iprot.readI32();
            setDIsSet(true);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MYINTLIST:
          if (field.type == TType.LIST) {
            {
              TList _list172 = iprot.readListBegin();
              this.myintlist = new ArrayList<Integer>(Math.max(0, _list172.size));
              for (int _i173 = 0; 
                   (_list172.size < 0) ? iprot.peekList() : (_i173 < _list172.size); 
                   ++_i173)
              {
                int _elem174;
                _elem174 = iprot.readI32();
                this.myintlist.add(_elem174);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MAPS:
          if (field.type == TType.MAP) {
            {
              TMap _map175 = iprot.readMapBegin();
              this.maps = new HashMap<Integer,Wrapper>(Math.max(0, 2*_map175.size));
              for (int _i176 = 0; 
                   (_map175.size < 0) ? iprot.peekMap() : (_i176 < _map175.size); 
                   ++_i176)
              {
                int _key177;
                Wrapper _val178;
                _key177 = iprot.readI32();
                _val178 = new Wrapper();
                _val178.read(iprot);
                this.maps.put(_key177, _val178);
              }
              iprot.readMapEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case BIGINT:
          if (field.type == TType.I64) {
            this.bigint = iprot.readI64();
            setBigintIsSet(true);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TRIPLE:
          if (field.type == TType.DOUBLE) {
            this.triple = iprot.readDouble();
            setTripleIsSet(true);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldBegin(A_FIELD_DESC);
    oprot.writeI32(this.a);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(B_FIELD_DESC);
    oprot.writeI32(this.b);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(C_FIELD_DESC);
    oprot.writeI32(this.c);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(D_FIELD_DESC);
    oprot.writeI32(this.d);
    oprot.writeFieldEnd();
    if (this.myintlist != null) {
      oprot.writeFieldBegin(MYINTLIST_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.I32, this.myintlist.size()));
        for (int _iter179 : this.myintlist)        {
          oprot.writeI32(_iter179);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.maps != null) {
      oprot.writeFieldBegin(MAPS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.I32, TType.STRUCT, this.maps.size()));
        for (Map.Entry<Integer, Wrapper> _iter180 : this.maps.entrySet())        {
          oprot.writeI32(_iter180.getKey());
          _iter180.getValue().write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(BIGINT_FIELD_DESC);
    oprot.writeI64(this.bigint);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(TRIPLE_FIELD_DESC);
    oprot.writeDouble(this.triple);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @Override
  public String toString() {
    return toString(DEFAULT_PRETTY_PRINT);
  }

  @Override
  public String toString(boolean prettyPrint) {
    return toString(1, prettyPrint);
  }

  @Override
  public String toString(int indent, boolean prettyPrint) {
    String indentStr = prettyPrint ? TBaseHelper.getIndentedString(indent) : "";
    String newLine = prettyPrint ? "\n" : "";
String space = prettyPrint ? " " : "";
    StringBuilder sb = new StringBuilder("RandomStuff");
    sb.append(space);
    sb.append("(");
    sb.append(newLine);
    boolean first = true;

    sb.append(indentStr);
    sb.append("a");
    sb.append(space);
    sb.append(":").append(space);
    sb.append(TBaseHelper.toString(this. getA(), indent + 1, prettyPrint));
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("b");
    sb.append(space);
    sb.append(":").append(space);
    sb.append(TBaseHelper.toString(this. getB(), indent + 1, prettyPrint));
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("c");
    sb.append(space);
    sb.append(":").append(space);
    sb.append(TBaseHelper.toString(this. getC(), indent + 1, prettyPrint));
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("d");
    sb.append(space);
    sb.append(":").append(space);
    sb.append(TBaseHelper.toString(this. getD(), indent + 1, prettyPrint));
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("myintlist");
    sb.append(space);
    sb.append(":").append(space);
    if (this. getMyintlist() == null) {
      sb.append("null");
    } else {
      sb.append(TBaseHelper.toString(this. getMyintlist(), indent + 1, prettyPrint));
    }
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("maps");
    sb.append(space);
    sb.append(":").append(space);
    if (this. getMaps() == null) {
      sb.append("null");
    } else {
      sb.append(TBaseHelper.toString(this. getMaps(), indent + 1, prettyPrint));
    }
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("bigint");
    sb.append(space);
    sb.append(":").append(space);
    sb.append(TBaseHelper.toString(this. getBigint(), indent + 1, prettyPrint));
    first = false;
    if (!first) sb.append("," + newLine);
    sb.append(indentStr);
    sb.append("triple");
    sb.append(space);
    sb.append(":").append(space);
    sb.append(TBaseHelper.toString(this. getTriple(), indent + 1, prettyPrint));
    first = false;
    sb.append(newLine + TBaseHelper.reduceIndent(indentStr));
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

